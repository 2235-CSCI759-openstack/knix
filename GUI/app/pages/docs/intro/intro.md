<!--
   Copyright 2020 The KNIX Authors

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
# Getting Started with KNIX MicroFunctions

Serverless computing is emerging as a key paradigm in cloud computing. Unlike traditional approaches, which require developers to bundle applications as servers inside VMs or containers, in serverless computing or Function-as-a-Service (FaaS) developers write applications as sets of standalone functions. These functions may be invoked via HTTP requests or triggered by other internal or external events. Developers do not need to manage servers or provision server capacity in advance because all aspects related to function execution, placement, scaling, etc., are handled by the serverless platform.

## Functions

At present, the KNIX MicroFunctions platform supports the Python 3.6 and Java 8 runtimes. Support for other languages is coming soon.   

Each Python/Java function must define a method named `handle` which is the default entry for that function. The `handle` method is invoked by the KNIX MicroFunctions platform when a request for that function arrives.

A MicroFunction application consists of one or more functions that can be grouped as one or multiple workflows. Workflows define the interactions among these functions. Workflows can be static, where the execution path of functions is fixed (e.g., function 2's execution always follows function 1's execution), or dynamic, where the execution path is determined during the execution (e.g., the execution of function 2 may be programmatically triggered by function 1's code). The function code and a workflow description are supplied by the application developer. A function can be used by multiple applications by referencing it in different workflows.

If the execution of a function fails then any subsequent functions (either statically defined or dynamically defined) will not be executed.

In order to create a new function in the KNIX MicroFunctions web GUI, click on the 'Functions' link shown on the left hand side. This will open up a page listing all the functions created by the current user. Add a new function by pressing the 'Add Function' button and giving it a name.

![](app/pages/docs/intro/mfn.gif "Create a function with the KNIX MicroFunctions web GUI")

A code editor window will open up automatically with the following code templates:

Python template for new function:

```
#!/usr/bin/python

def handle(event, context):

    return ""
```

Java template for new function:

```
import org.microfunctions.mfnapi.MicroFunctionsAPI;

public class test
{
	public Object handle(Object event, MicroFunctionsAPI context)
	{
		return "";
	}
}
```

You can write your function code in the editor and press 'Save'. Alternatively, function code can be written offline and uploaded using the code editor. To upload function code, click the 'Upload' tab and browse to the file containing the code. This file will be uploaded as the function code which will become available in the editor after uploading finishes.

There are two input parameters to the `handle()` method of each function:

1. `event`: The input value to functions on the KNIX MicroFunctions platform must be a JSON text string. It is converted by the platform to a Python dict/Java Object which is passed to the function handler as the `event` parameter. The function code is responsible for validating if the `event` object is in the expected format.

2. `context`: This is the MicroFunctions API object, which exposes APIs for KNIX MicroFunctions's key-value object store, logging, and dynamic invocation of functions.

Individual functions can be tested by clicking the 'Test' button next to the function. This will open a window where the function can be executed with a user provided input. The input must be a JSON text string. The bottom half of the window shows the function's return value and logs generated by the function.

## Creating a function with custom libraries or other dependencies

Dependencies that are not part of the standard Python distribution, such as those that can be installed via `pip install` or your own custom packages, can easily be included with your function code by creating a deployment package for the function. To create this package, first store the function code in a local folder. Next, copy all dependencies to this folder next to the function code. For example, you can use `pip install <package name> -t .` to install a Python package directly into this folder. Afterwards, zip the contents of this folder via `zip -r ../<functionname>.zip .` command or create a jar file in the case of Java. This zip/jar file is the deployment package for the function.

Next, create a function and upload the zip/jar file using the 'Upload' tab. KNIX MicroFunctions will automatically extract the contents of the zip/jar file and display it after uploading has finished. Afterwards, you may view/modify your function code using the function code editor. Any updates made to the code will be used when deploying a workflow involving this function. Note that your function code's filename (i.e., <functionname>.py|java) must match the function name you create in the web GUI (i.e., <functionname>).

KNIX MicroFunctions currently supports only zip/jar archives.

Alternatively, if your Python function only requires packages that are pip-installable, they can be listed in the 'Requirements' tab of the function code editor window in the format of a pip 'requirements.txt' file, e.g.,:

```
PyYAML
Pygments
SQLAlchemy==0.7.1
anyjson==0.3
```

Required functions for Java functions can be specified in the format of a Maven pom.xml file:

```
<dependency>
  <groupId>eu.lundegaard.commons.java</groupId>
  <artifactId>jackson</artifactId>
  <version>3.2.0</version>
</dependency>
```

## <span id="qrcode"></span>QR Code Generator Example

In this example we will create a Python function that uses a library to encode a text string, such as a URL, as a QR code. We will store the QR code image in the KNIX MicroFunctions object store and also return it as the function output. The Python function code is shown below. The function makes use of two Python libraries named `qrcode` and `pillow` respectively which need to specified as a requirement to the function in the 'Requirements' tab of the code editor. All libraries listed in the 'Requirements' tab will be 'pip installed' when the corresponding function is deployed as part of a workflow or during a test execution.

```
#!/usr/bin/python
import qrcode
import base64
import json
from io import BytesIO
from PIL import Image

def handle(event, context):

    # Check if function input JSON contains targetURL field
    if 'targetURL' not in event:
        raise ValueError("No 'targetURL' field in JSON input data")

    # Create QR code for target URL
    img = qrcode.make(event['targetURL'])

    # Save qrcode output as JPG image
    buffered = BytesIO()
    img.save(buffered, format="JPEG")

    # base64-encode img data
    qr_b64 = base64.b64encode(buffered.getvalue()).decode()

    # Store img in MicroFunctions object store
    context.put('qrcode.jpg', qr_b64)

    # Log status
    context.log("Saved QR code image as qrcode.jpg to object store")

    # Return HTML snippet with img data encoded inline
    return "<img src='data:image/jpeg;base64," + qr_b64 + "';>"
```

Our function expects a JSON object as input that contains a field 'targetURL' which specifies the target of the QR code to be generated. The function throws a ValueError exception if the field is not present. Here is an example JSON function input:

```
{ "targetURL" : "https://microfunctions.org" }
```

which generates the QR code below. The QR code image is saved to the object store under the name 'qrcode.jpg'. Please note that the image data needs to be base64-encoded since the `context.put(key, value)` method expects `key` and `value` parameters to be Python strings. It can be downloaded from there by navigating to the 'Object Store' in the web GUI. The `context.log(logEntry)` call writes a line to the function execution log that can be viewed in the function/workflow execution dialog. The output of Python `print` statements and error log entries also show up in the same execution log. Our example function returns the image data along with an HTML snippet which allows the image to be viewed directly in the function/workflow execution dialog of the web GUI by selecting 'HTML' in the 'Execution Output' tab.

![QR Code](app/pages/docs/usecases/qrcode.jpg "QR code for 'http://microfunctions.org'")

<a href="?importWorkflow=qrgen.zip#/workflows" class="btn btn-primary">
    Import QR Generator Example Code
</a>

## Workflows

Workflows on the KNIX MicroFunctions platform consist of a JSON-encoded definition that specifies which functions are part of the workflow and controls the order of their execution. The KNIX MicroFunctions platform supports the Amazon States Language (ASL). ASL is used to define a step function state machine for AWS Lambda. You can find more information about ASL here: <https://states-language.net/spec.html>

In the web GUI, you will see a link on the left hand side, named 'Workflows'. This page lists all the workflows you have created so far as well as their status (i.e., deployed/undeployed) and their publicly accessible URL to trigger them via a web browser or command line tools (such as curl and wget).

## Workflow Definition

To create a new workflow, click on 'Add a Workflow' and enter a name for your workflow which brings up the workflow editor with the following workflow definition template:

```
{
	"Comment": "Example Workflow",
	"StartAt": "",
	"States": {
		"": {
			"Type": "Task",
			"Resource": "",
			"End": true
		}
	}
}
```

Each 'Resource' field in your ASL specification must be assigned to the name of a function in your KNIX MicroFunctions account (instead of an AWS Lambda function identifier as is the case for Amazon Step Functions). Support for some less common ASL features such as the `Map` state or the `Parameters` field will be added to the KNIX MicroFunctions platform soon.

## Workflow Editor

The workflow editor lets you edit or upload your workflow definition as well as each function referenced in the workflow. A tab for each workflow function appears after the workflow definition has been saved. The workflow editor also has a tab that shows a visualization of the workflow. From the workflow editor you can also deploy or redeploy the workflow and open the workflow execution dialog.

![](app/pages/docs/intro/wf.gif "Create a workflow with the KNIX MicroFunctions web GUI")

## Workflow Execution

The workflow execution dialog lets you execute a deployed workflow through the web GUI. You can enter a JSON text string as the workflow input, execute the workflow, see a timeline of all executed functions, as well as the workflow logs. It also shows a visualization of the workflow execution path including the execution status (success/failure) of each executed function. The workflow output can be viewed as JSON or interpreted as HTML. Mousing over a function execution in the timeline brings up a pop-up window with the function execution statistics and any log output of the function (including error messages). In the case of an function execution failure due to a user code error a 'Go to Error' button appears as a means to quickly view the corresponding function code in the workflow editor. The line the caused the error will be highlighted in red.

![](app/pages/docs/intro/wf_exec.gif "Execute a workflow with the KNIX MicroFunctions web GUI")

## KNIX MicroFunctions Object Store

The KNIX MicroFunctions key value object store serves as the data layer of the KNIX MicroFunctions platform and can be used to externalize state in between function calls or persist data objects, similar to Amazon's S3.   

The keys and values used in the put, get, and delete operations must be strings. Non-ASCII values must be based64-encoded and decoded by the user code.

By default, the items will be written into the data layer of the user, so that the items produced by one workflow will be accessible by another workflow that belongs to the same user. Sharing across users is currently not supported.

Additionally, one can use another parameter (i.e., `is_private = True`) in all these operations to access a workflow-private key-value store, so that the items will only be accessible to the corresponding workflow.

By default, all items put and deleted from the key-value store are immediately made available in the global data layer without waiting for the function execution to finish. One can set another parameter (`is_queued = True`) to postpone the operation to the global data layer, so that it will only happen if the function execution successfully finishes. By default all items available in the global data layer can be accessed via any function defined by the same user. Access to data items can also be limited to functions belonging to a single workflow.

These concepts are illustrated in the following sample invocations to the `put` API:

`context.put('mykey', 'myvalue')`: `mykey` will be available to all workflows of the user, and will also be made available immediately in the global data layer.

`context.put('mykey', 'myvalue', is_private = True)`: `mykey` will be available only to this workflow's functions, and will also be made available immediately in the global data layer.

`context.put('mykey', 'myvalue', is_queued = True)`: `mykey` will be available to all workflows of the user, and will be made available in the global data layer after the function execution successfully finishes.

`context.put('mykey', 'myvalue', is_private = True, is_queued = True)`: `mykey` will be available only to this workflow's functions, and will be made available in the global data layer after the function execution successfully finishes.

The `context.get('mykey')` call returns a previously stored object.

Objects can also be uploaded to and downloaded from the KNIX MicroFunctions object store using the web GUI.
