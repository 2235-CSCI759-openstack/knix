<!--
   Copyright 2020 The KNIX Authors

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>MicroFunctionsAPI API documentation</title>
<meta name="description" content="The MicroFunctions API accessible by functions." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body bgcolor="#fff">
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MicroFunctionsAPI</code></h1>
</header>
<section id="section-intro">
<p>The MicroFunctions API accessible by functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#   Copyright 2020 The KNIX Authors
#
#   Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

&#39;&#39;&#39;
The MicroFunctions API accessible by functions.
&#39;&#39;&#39;

from DataLayerClient import DataLayerClient
from DataLayerOperator import DataLayerOperator
from MicroFunctionsExceptions import MicroFunctionsWorkflowException, MicroFunctionsSessionAPIException, MicroFunctionsUserLogException, MicroFunctionsDataLayerException

import py3utils
import requests
import json

class MicroFunctionsAPI:
    &#39;&#39;&#39;
    This class defines the API that is exposed to the user functions.
    An object of this class is passed to the user function along with the input event.
    It enables operations related to the following features:
    - logging
    - data layer access
    - dynamic generation of workflows
    - communication with other (sesssion or regular) functions during execution
    - session customization
    &#39;&#39;&#39;
    def __init__(self, uid, sid, wid, funcstatename, key, publication_utils, is_session_workflow, is_session_function, session_utils, logger, datalayer, nginx, useremail, usertoken):
        &#39;&#39;&#39;
        Initialize data structures for MicroFunctionsAPI object created for a function instance.

        Args:
            uid (string): user id
            sid (string): sandbox id
            wid (string): workflow id
            logger (logger): log object
            funcstatename (string): function&#39;s state name
            key (string): key of the input message
            datalayer (string): host:port of the local data layer server
            nginx (string): host:port of the mfn nginx server
            useremail (string): email address of the user

        Returns:
            None
        &#39;&#39;&#39;

        self._logger = logger
        self._datalayer = datalayer
        self._nginx = nginx
        self._useremail = useremail
        self._usertoken = usertoken

        self._data_layer_operator = DataLayerOperator(uid, sid, wid, self._datalayer)

        # for sending immediate triggers to other functions
        self._publication_utils = publication_utils

        self._is_session_workflow = is_session_workflow
        self._is_session_function = is_session_function
        self._session_utils = session_utils

        self._function_state_name = funcstatename
        self._function_version = 1

        self._instanceid = key

        self._is_privileged = False
        if sid == &#34;SandService&#34; and wid == &#34;Management&#34;:
            self._is_privileged = True

        #self._logger.info(&#34;[MicroFunctionsAPI] init done.&#34;)

    def ping(self, num):
        self._logger.info(&#34;ping:&#34; + str(num))
        output = num
        return &#39;pong &#39; + str(output)

    def get_privileged_data_layer_client(self, suid=None, keyspace=None, tablename=None, maptablename=None, settablename=None, countertablename=None, init_tables=False):
        if self._is_privileged:
            if suid is not None:
                return DataLayerClient(locality=1, suid=suid, connect=self._datalayer, init_tables=init_tables)
            elif keyspace is not None and tablename is not None:
                dlc = DataLayerClient(locality=1, for_mfn=True, connect=self._datalayer)
                dlc.keyspace = keyspace
                dlc.tablename = tablename
                if maptablename is not None:
                    dlc.maptablename = maptablename
                if settablename is not None:
                    dlc.settablename = settablename
                if countertablename is not None:
                    dlc.countertablename = countertablename
                return dlc
        return None

    def update_metadata(self, metadata_name, metadata_value, is_privileged_metadata=False):
        is_privileged = False
        if is_privileged_metadata and self._is_privileged:
            is_privileged = True

        self._publication_utils.update_metadata(metadata_name, metadata_value, is_privileged=is_privileged)

    # session related API calls
    # only valid if the workflow has at least one session function
    def send_to_running_function_in_session(self, rgid, message, send_now=False):
        &#39;&#39;&#39;
        Send a message to a long-running session function instance identified with its id in this session.

        Args:
            rgid (string): the running long-running session function instance&#39;s id.
            message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
            send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

        Returns:
            None

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        message = self._publication_utils.convert_api_message_to_python_object(message)

        if not self._publication_utils.is_valid_value(message):
            errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
            raise MicroFunctionsSessionAPIException(errmsg)

        if self._is_session_workflow:
            self._session_utils.send_to_running_function_in_session(rgid, message, send_now)
        else:
            self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)

    def send_to_all_running_functions_in_session_with_function_name(self, gname, message, send_now=False):
        &#39;&#39;&#39;
        Send a message to all long-running session function instances identified with their function name in this session.
        There can be multiple instances with the same function name, which will all receive the message.
        The function name refers to the function name;
        it is not to be confused with the &#39;alias&#39; that may have been assigned to each long-running, session function instance.

        Args:
            gname (string): the function name (i.e., function name) of the running long-running session function instance(s).
            message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
            send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

        Returns:
            None

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        message = self._publication_utils.convert_api_message_to_python_object(message)

        if not self._publication_utils.is_valid_value(message):
            errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
            raise MicroFunctionsSessionAPIException(errmsg)

        if self._is_session_workflow:
            self._session_utils.send_to_all_running_functions_in_session_with_function_name(gname, message, send_now)
        else:
            self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)

    def send_to_all_running_functions_in_session(self, message, send_now=False):
        &#39;&#39;&#39;
        Send a message to all long-running session function instances in this session.

        Args:
            message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
            send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

        Returns:
            None

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        message = self._publication_utils.convert_api_message_to_python_object(message)

        if not self._publication_utils.is_valid_value(message):
            errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
            raise MicroFunctionsSessionAPIException(errmsg)

        if self._is_session_workflow:
            self._session_utils.send_to_all_running_functions_in_session(message, send_now)
        else:
            self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)

    def send_to_running_function_in_session_with_alias(self, alias, message, send_now=False):
        &#39;&#39;&#39;
        Send a message to a long-running session function instance identified with its alias in this session.
        The alias would have to be assigned before calling this function.
        The alias can belong to only a single long-running, session function instance.

        Args:
            alias (string): the alias of the running long-running session function instance that is the destination of the message.
            message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
            send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

        Returns:
            None

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        message = self._publication_utils.convert_api_message_to_python_object(message)

        if not self._publication_utils.is_valid_value(message):
            errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
            raise MicroFunctionsSessionAPIException(errmsg)

        if self._is_session_workflow:
            self._session_utils.send_to_running_function_in_session_with_alias(alias, message, send_now)
        else:
            self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)

    def get_session_update_messages(self, count=1):
        &#39;&#39;&#39;
        Retrieve the list of update messages sent to a session function instance.
        The list contains messages that were sent and delivered since the last time the session function instance has retrieved it.
        These messages are retrieved via a local queue. There can be more than one message.
        The optional count argument specifies how many messages should be retrieved.
        If there are fewer messages than the requested count, all messages will be retrieved and returned.

        Args:
            count (int): the number of messages to retrieve; default: 1

        Returns:
            List of messages that were sent to the session function instance.

        Warns:
            When the calling function is not a session function.

        &#39;&#39;&#39;
        messages = []
        if self._is_session_function:
            #self._logger.info(&#34;[MicroFunctionsAPI] getting session update messages...&#34;)
            messages = self._session_utils.get_session_update_messages_with_local_queue(count)
        else:
            self._logger.warning(&#34;Cannot get session update messages in a non-session function: &#34; + self._function_state_name)

        return messages

    def set_session_alias(self, alias):
        &#39;&#39;&#39;
        Assign an alias to the current session.

        Args:
            alias (string): the custom name to be assigned to the session.

        Returns:
            None

        Raises:
            MicroFunctionsSessionAPIException: when the alias is not a string, or is empty string.

        Warns:
            When the alias is already in use by another session.

        &#39;&#39;&#39;
        if not py3utils.is_string(alias) or alias == &#34;&#34;:
            raise MicroFunctionsSessionAPIException(&#34;Invalid session alias; must be a non-empty string.&#34;)
        elif alias == &#34;&#34;:
            raise MicroFunctionsSessionAPIException(&#34;Session alias cannot be empty.&#34;)

        if self._is_session_workflow:
            self._session_utils.set_session_alias(alias)
        else:
            self._logger.warning(&#34;Cannot set a session alias in a workflow with no session functions.&#34;)

    def unset_session_alias(self):
        &#39;&#39;&#39;
        Remove the existing alias of the current session.

        Args:
            None

        Returns:
            None

        &#39;&#39;&#39;
        self._session_utils.unset_session_alias()

    def get_session_alias(self):
        &#39;&#39;&#39;
        Retrieve the existing alias of the current session.

        Args:
            None

        Returns:
            The existing session alias (string) or None if no alias is set.

        &#39;&#39;&#39;
        if self._is_session_workflow:
            return self._session_utils.get_session_alias()
        else:
            self._logger.warning(&#34;Cannot get a session alias in a workflow with no session functions.&#34;)
        return None

    def set_session_function_alias(self, alias, session_function_id=None):
        &#39;&#39;&#39;
        Assign an alias to a session function instance in this session.
        If the session function id is not set, the alias will be assigned to the calling function instance.
        If it is set, the alias will be assigned to the function instance with the given id.

        Args:
            alias (string): the custom name to be assigned to the session function instance.
            session_function_id (string): the session function instance id for which this alias should be assigned; default: None

        Returns:
            None

        Raises:
            MicroFunctionsSessionAPIException: when the alias is not a string, or is empty string

        Warns:
            When calling function is not a session function.
            When no session function instance exists with the given session function id.
            When the alias is already in use by another existing session function instance.

        &#39;&#39;&#39;
        if not py3utils.is_string(alias):
            raise MicroFunctionsSessionAPIException(&#34;Invalid session function alias; must be a non-empty string.&#34;)
        elif alias == &#34;&#34;:
            raise MicroFunctionsSessionAPIException(&#34;Session function alias cannot be empty.&#34;)

        # handle another session function&#39;s alias
        if session_function_id is not None:
            self._session_utils.set_session_function_alias(alias, session_function_id)
        elif self._is_session_function:
            self._session_utils.set_session_function_alias(alias)
        else:
            self._logger.warning(&#34;Cannot set a session function alias in a non-session function.&#34;)

    def unset_session_function_alias(self, session_function_id=None):
        &#39;&#39;&#39;
        Remove the current alias of the session function instance in this session.
        If the session function id is not set, the current function instance&#39;s alias will be removed.
        If it is set, the alias of the session function instance corresponding to the id will be removed.

        Args:
            session_function_id (string): the id of the session function instance whose alias should be removed; default: None.

        Returns:
            None

        Warns:
            When calling function is not a session function if session function id is None.
            When no session function instance exists with the given session function id.

        &#39;&#39;&#39;
        # handle another session function&#39;s alias
        if session_function_id is not None:
            self._session_utils.unset_session_function_alias(session_function_id)
        elif self._is_session_function:
            self._session_utils.unset_session_function_alias()
        else:
            self._logger.warning(&#34;Cannot unset a session function alias in a non-session function.&#34;)

    def get_session_function_alias(self, session_function_id=None):
        &#39;&#39;&#39;
        Retrieve the current alias of the session function instance in this session.
        If the session function id is not set, the current function instance&#39;s alias will be retrieved.
        If it is set, the alias of the session function instance corresponding to the id will be retrieved.

        Args:
            session_function_id (string): the id of the session function instance whose alias should be retrieved; default: None.

        Returns:
            The existing alias of the session function instance (string) or None if no alias is set.

        Warns:
            When calling function is not a session function if session function id is None.
            When no session function instance exists with the given session function id.

        &#39;&#39;&#39;
        # handle another session function&#39;s alias
        if session_function_id is not None:
            return self._session_utils.get_session_function_alias(session_function_id)
        elif self._is_session_function:
            return self._session_utils.get_session_function_alias()
        else:
            self._logger.warning(&#34;Cannot get a session function alias in a non-session function.&#34;)
        return None

    def get_all_session_function_aliases(self):
        &#39;&#39;&#39;
        Retrieve the session function instance and alias mapping for all the session function instances in this session.

        Args:
            None

        Returns:
            A dictionary with session function instance id as the key and the alias as the value involving all session function instances in this session.

        Warns:
            When the calling function is not part of a workflow with at least one session function.

        &#39;&#39;&#39;
        aliases = {}
        if self._is_session_workflow:
            aliases = self._session_utils.get_all_session_function_aliases()
        else:
            self._logger.warning(&#34;Cannot get session function aliases in a workflow with no session functions.&#34;)
        return aliases

    def get_alias_summary(self):
        &#39;&#39;&#39;
        Retrieve a summary of the aliases of the current session and its session function instances.

        Args:
            None

        Returns:
            Dictionary with two keys -- &#39;session&#39; and &#39;session_functions&#39;, each referring to another dictionary.
            &#39;session&#39; dictionary will have an item with the session id as the key and the session alias as the value.
            &#39;session_functions&#39; dictionary will have one or more entries, where each key will be the id of a session function instance
            and the corresponding value will be the alias assigned to that session function instance.
            If any alias is not set, then the values will be None.

        Warns:
            When the calling function is not part of a workflow with at least one session function.

        &#39;&#39;&#39;
        alias_summary = {}
        if self._is_session_workflow:
            alias_summary = self._session_utils.get_alias_summary()
        else:
            self._logger.warning(&#34;Cannot get alias summary for session in a workflow with no session functions.&#34;)
        return alias_summary

    def get_session_id(self):
        &#39;&#39;&#39;
        Retrieve the current session&#39;s id.

        Args:
            None

        Returns:
            The session id of the current session.

        Warns:
            When the calling function is not part of a workflow with at least one session function.

        &#39;&#39;&#39;
        if self._is_session_workflow:
            return self._session_utils.get_session_id()
        else:
            self._logger.warning(&#34;Cannot get a session id in a workflow with no session functions.&#34;)
        return None

    def get_session_function_id(self):
        &#39;&#39;&#39;
        Retrieve the current session function instance&#39;s id.

        Args:
            None

        Returns:
            The id of the current session function instance.

        Warns:
            When the calling function is not a session function.

        &#39;&#39;&#39;
        if self._is_session_function:
            return self._session_utils.get_session_function_id()
        else:
            self._logger.warning(&#34;Cannot get session function id in a non-session function.&#34;)
        return None

    def get_session_function_id_with_alias(self, alias=None):
        &#39;&#39;&#39;
        Retrieve the id of a session function instance using an alias.
        When alias is not set, the id of the current session function instance will be returned.
        When it is not set, the id of the session function instance with that alias will be returned.

        Args:
            alias (string): The alias that needs to be used to retrieve the id of the session function instance; default: None

        Returns:
            The id of the current session function instance when alias is not set, or the ide of the session function instance with the given alias.

        Warns:
            When the calling function is not a session function if the alias is not given.

        &#39;&#39;&#39;
        # handle another session function&#39;s alias
        if alias is not None:
            return self._session_utils.get_session_function_id_with_alias(alias)
        elif self._is_session_function:
            return self._session_utils.get_session_function_id_with_alias()
        else:
            self._logger.warning(&#34;Cannot get session function id in a non-session function.&#34;)
        return None

    def get_all_session_function_ids(self):
        &#39;&#39;&#39;
        Retrieve a list of all ids of the session function instances in this session.

        Args:
            None

        Returns:
            List of ids of all the session function instances in this session.

        Warns:
            When the calling function is not part of a workflow with at least one session function.

        &#39;&#39;&#39;
        rgidlist = []
        if self._is_session_workflow:
            rgidlist = self._session_utils.get_all_session_function_ids()
        else:
            self._logger.warning(&#34;Cannot get session function ids in a workflow with no session functions.&#34;)
        return rgidlist

    def is_still_running(self):
        &#39;&#39;&#39;
        Retrieve the status of this session function instance.
        The status of the session function instance could have been changed via a special message
        delivered to the session function instance and handled by the platform.
        A session function should call this method to handle such cases.

        Args:
            None

        Returns:
            True if the session function instance has not received a special message to stop, or False otherwise.

        Warns:
            When the calling function is not a session function.

        &#39;&#39;&#39;
        if self._is_session_function:
            return self._session_utils.is_session_function_running()
        else:
            self._logger.warning(&#34;Cannot get status of running in a non-session function.&#34;)
        return None

    ##########################
    # _XXX_: API call changes:
    # 1. for better function names that reflect the intention (e.g., add_workflow_next)
    # 2. new API call for sending immediate messages
    # 2.1 need to get a list of functions in this sandbox for sanity checking
    # (i.e., messages should only be sent to functions listed in this sandbox)
    # 3. better checking of _wf_pot_next
    # (i.e., when adding a dynamic trigger rather than publishing at the end of execution)
    # 4. optimization of the trigger validity check
    def add_workflow_next(self, next, value):
        &#39;&#39;&#39;
        Construct a dynamic trigger and add it to the workflow.
        The dynamic trigger will define the next function to be executed after this function
        and the value that will be passed as input to the next function.
        If the &#39;value&#39; field is not used, the &#39;next&#39; function will be executed with an empty string as input.

        Args:
            next (string): the function name to be executed after this function; must be of a string.
            value: the input value to be passed to the next function; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        Returns:
            None

        Raises:
            MicroFunctionsWorkflowException: when either &#39;next&#39; is not a string or &#39;value&#39; is not a valid python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        value = self._publication_utils.convert_api_message_to_python_object(value)

        is_valid, is_privileged, errmsg = self._publication_utils.is_valid_trigger_message(next, value, False)

        if is_valid:
            trigger = {}
            trigger[&#34;next&#34;] = next
            trigger[&#34;value&#34;] = value
            trigger[&#34;is_privileged&#34;] = is_privileged
            self._publication_utils.append_trigger(trigger)
        else:
            raise MicroFunctionsWorkflowException(errmsg)

    def add_dynamic_next(self, next, value):
        &#39;&#39;&#39;
        Alias for add_workflow_next(self, next, value).
        &#39;&#39;&#39;
        self.add_workflow_next(next, value)

    def send_to_function_now(self, destination, value):
        &#39;&#39;&#39;
        Send a new event message to another function immediately instead of waiting until the end of the current function execution.
        The destination can be any function in the workflow description.
        The value must be a python data type.

        Args:
            destination (string): the destination of the message
            value (*): message to be sent; must be a python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        Raises:
            MicroFunctionsWorkflowException: when either the destination is not a string or the value is not a python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        value = self._publication_utils.convert_api_message_to_python_object(value)

        is_valid, is_privileged, errmsg = self._publication_utils.is_valid_trigger_message(destination, value, True)

        if is_valid:
            trigger = {}
            trigger[&#34;next&#34;] = destination
            trigger[&#34;value&#34;] = value
            trigger[&#34;is_privileged&#34;] = is_privileged
            self._publication_utils.send_to_function_now(self._instanceid, trigger)
        else:
            raise MicroFunctionsWorkflowException(errmsg)

    #########################

    def add_dynamic_workflow(self, dynamic_trigger):
        &#39;&#39;&#39;
        Add dynamically generated trigger(s) to the workflow.
        The dynamically generated trigger can be a single dictionary with &#39;next&#39; and &#39;value&#39; fields,
        or a list of dictionaries with &#39;next&#39; and &#39;value&#39; fields.
        In each dictionary, the &#39;next&#39; field defines the next function that needs to be triggered.
        The &#39;value&#39; field defines the input to the respective next function.
        This function will check the validity of the dictionary and raise MicroFunctionsWorkflowException if either &#39;next&#39; is not a string or &#39;value&#39; is not a valid python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        Args:
            dynamic_trigger (list of dicts, or dict): each dictionary must be of the form: {&#39;next&#39;: &lt;type &#39;str&#39;&gt;, &#39;value&#39;: &lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;}

        Returns:
            None

        Raises:
            MicroFunctionsWorkflowException: when the input is neither a list of dictionaries or a single dictionary.
            MicroFunctionsWorkflowException: when in a dictionary, &#39;next&#39; or &#39;value&#39; is missing.

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        dynamic_trigger = self._publication_utils.convert_api_message_to_python_object(dynamic_trigger)

        is_valid = True
        # &#39;dynamic_trigger&#39; can be a single dictionary or a list of dictionaries.
        # each dictionary must be of the form: {&#39;next&#39;: &lt;type &#39;str&#39;&gt;, &#39;value&#39;: &lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;}
        if isinstance(dynamic_trigger, dict):
            if &#39;next&#39; in dynamic_trigger and &#39;value&#39; in dynamic_trigger:
                self.add_workflow_next(dynamic_trigger[&#39;next&#39;], dynamic_trigger[&#39;value&#39;])
            else:
                errmsg = &#34;Malformed dynamic trigger definition; &#39;next&#39; and &#39;value&#39; must be present in the trigger dict().&#34;
                is_valid = False
        elif isinstance(dynamic_trigger, list):
            for trigger in dynamic_trigger:
                if &#39;next&#39; in trigger and &#39;value&#39; in trigger:
                    self.add_workflow_next(trigger[&#39;next&#39;], trigger[&#39;value&#39;])
                else:
                    errmsg = &#34;Malformed dynamic trigger definition; &#39;next&#39; and &#39;value&#39; must be present in the trigger dict().&#34;
                    is_valid = False
                    break
        else:
            errmsg = &#34;Malformed dynamic trigger definition; use either a dict() with &#39;next&#39; and &#39;value&#39; fields or a list of dict().&#34;
            is_valid = False

        if not is_valid:
            raise MicroFunctionsWorkflowException(errmsg)

    def get_dynamic_workflow(self):
        &#39;&#39;&#39;
        Return the dynamically generated workflow information,
        so that this function instance can trigger other functions when it finishes.
        &#39;&#39;&#39;
        return self._publication_utils.get_dynamic_workflow()

    #########################

    def get_remaining_time_in_millis(self):
        &#39;&#39;&#39;
        Return the remaining time this function instance is allowed to continue running.
        The time is returned in milliseconds.
        This function exists for AWS Lambda compatibility.
        As of 10.04.2018, the maximum time a function instance can execute is not limited.
        This will change in the future.
        &#39;&#39;&#39;
        # 5 minutes always
        return 300000

    def log(self, text, level=&#34;INFO&#34;):
        &#39;&#39;&#39;
        Log text. Uses the instance id to indicate which function instance logged the text.

        Args:
            text (string): text to be logged.
            level (string): log level to be used.
        Returns:
            None.

        Raises:
            MicroFunctionsUserLogException: when there are any errors in the logging function.
        &#39;&#39;&#39;

        if level == &#34;INFO&#34;:
            self._logger.info(text)
        elif level == &#34;WARNING&#34;:
            self._logger.warning(text)
        elif level == &#34;DEBUG&#34;:
            self._logger.debug(text)
        elif level == &#34;ERROR&#34;:
            self._logger.error(text)
        else:
            raise MicroFunctionsUserLogException(&#34;User logging exception; unsupported log level: &#34; + str(level))

    def get_event_key(self):
        &#39;&#39;&#39;
        Return the function instance id (i.e., the key of the trigger event).
        &#39;&#39;&#39;
        return self._instanceid


    def get_instance_id(self):
        &#39;&#39;&#39;
        Return the function instance id (i.e., the key of the trigger event).
        &#39;&#39;&#39;
        return self._instanceid

    def put(self, key, value, is_private=False, is_queued=False, tableName=None):
        &#39;&#39;&#39;
        Access to data layer to store a data item in the form of a (key, value) pair.
        By default, the put operation is reflected on the data layer immediately.
        If the put operation is queued (i.e., is_queued = True),
        the data item is put into the transient data table.
        If the key was previously deleted by the function instance,
        it is removed from the list of items to be deleted.
        When the function instance finishes,
        the transient data items are committed to the data layer.

        Args:
            key (string): the key of the data item
            value (string): the value of the data item
            is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
            is_queued (boolean): whether the put operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the put operation will be reflected on the data layer immediately)
            tableName (string): name of the table where to put the key. By default, it will be put in the default table.

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the key and/or value are not strings.
        &#39;&#39;&#39;
        if py3utils.is_string(key) and py3utils.is_string(value) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.put(key, value, is_private, is_queued, table=tableName)
        else:
            errmsg = &#34;MicroFunctionsAPI.put(key, value) accepts a string as &#39;key&#39; and &#39;value&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def get(self, key, is_private=False, tableName=None):
        &#39;&#39;&#39;
        Access to data layer to load the value of a given key.
        The key is first checked in the transient deleted items.
        If it is not deleted, the key is then checked in the transient data table.
        If it is not there, it is retrieved from the global data layer.
        As a result, the value returned is consistent with
        what this function instance does with the data item.
        If the data item is not present in either the transient data table
        nor in the global data layer, an empty string (i.e., &#34;&#34;) will be
        returned.
        If the function used put() and delete() operations with is_queued=False (default),
        then the checks of the transient table will result in empty values,
        so that the item will be retrieved from the global data layer.

        Args:
            key (string): the key of the data item
            is_private (boolean): whether the item should be read from the private data layer of the workflow; default: False
            tableName (string): name of the table where to get the key from. By default, it will be fetched from the default table.

        Returns:
            value (string): the value of the data item; empty string if the data item is not present.

        Raises:
            MicroFunctionsDataLayerException: when the key is not a string.
        &#39;&#39;&#39;
        # check first transient_output
        # if not there, return the actual (global) data layer data item
        # if not there either, return empty string (as defined in the DataLayerClient)
        if py3utils.is_string(key) and isinstance(is_private, bool):
            return self._data_layer_operator.get(key, is_private, table=tableName)
        else:
            errmsg = &#34;MicroFunctionsAPI.get(key) accepts a string as &#39;key&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def delete(self, key, is_private=False, is_queued=False, tableName=None):
        &#39;&#39;&#39;
        Alias for remove(key, is_private, is_queued, tableName).
        &#39;&#39;&#39;
        self.remove(key, is_private, is_queued, tableName)

    def remove(self, key, is_private=False, is_queued=False, tableName=None):
        &#39;&#39;&#39;
        Access to data layer to remove data item associated with a given key.
        By default, the remove operation is reflected on the data layer immediately.
        If the delete operation is queued (i.e., is_queued = True),
        the key is removed from the transient data table.
        It is also added to the list of items to be deleted from the global
        data layer when the function instance finishes.

        Args:
            key (string): the key of the data item
            is_private (boolean): whether the item should be deleted from the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)
            tableName (string): name of the table where to remove the key from. By default, it will be deleted from the default table.

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the key is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(key) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.delete(key, is_private, is_queued, table=tableName)
        else:
            errmsg = &#34;MicroFunctionsAPI.delete(key) accepts a string as &#39;key&#39;&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    # map operations sanity checking
    def createMap(self, mapname, is_private=False, is_queued=False):
        # _XXX_: the backend at the data layer does not create
        # sets and maps (i.e., createSet, createMap) until an entry is made
        # the addition of the entries will succeed without requiring the
        # corresponding set/map to have been created.
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map to be created
            is_private (boolean): whether the map should be created in the private data layer of the workflow; default: False
            is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the create operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        self._logger.warning(&#34;MicroFunctionsAPI.createMap() does not have an effect; it will be removed in the future.&#34;)
        self._logger.warning(&#34;(Entries can still be added without calling createMap() beforehand.)&#34;)
        return
        #if py3utils.is_string(mapname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        #    self._data_layer_operator.createMap(mapname, is_private, is_queued)
        #else:
        #    errmsg = &#34;MicroFunctionsAPI.createMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
        #    errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        #    raise MicroFunctionsDataLayerException(errmsg)

    def putMapEntry(self, mapname, key, value, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map
            key (string): the key of the data item
            value (string): the value of the data item
            is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
            is_queued (boolean): whether the put operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the put operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when any of mapname, key and value is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and py3utils.is_string(key) and py3utils.is_string(value) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.putMapEntry(mapname, key, value, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.putMapEntry(mapname, key, value) accepts a string as &#39;mapname&#39;, &#39;key&#39; and &#39;value&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getMapEntry(self, mapname, key, is_private=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map
            key (string): the key of the data item
            is_private (boolean): whether the item should be retrieved from the private data layer of the workflow; default: False

        Returns:
            The value associated with the key in the map (string), or empty string &#34;&#34; if the key does not exist.

        Raises:
            MicroFunctionsDataLayerException: when any of mapname and key is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool):
            return self._data_layer_operator.getMapEntry(mapname, key, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getMapEntry(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def deleteMapEntry(self, mapname, key, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map
            key (string): the key of the data item
            is_private (boolean): whether the item should be deleted from the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when any of mapname and key is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.deleteMapEntry(mapname, key, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.deleteMapEntry(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def containsMapKey(self, mapname, key, is_private=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map
            key (string): the key of the data item
            is_private (boolean): whether the map should be checked in the private data layer of the workflow; default: False

        Returns:
            True if key exists in the map; False otherwise (boolean)

        Raises:
            MicroFunctionsDataLayerException: when any of mapname and key is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool):
            return self._data_layer_operator.containsMapKey(mapname, key, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.containsMapKey(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getMapKeys(self, mapname, is_private=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map whose keys are to be retrieved
            is_private (boolean): whether the map should be retrieved from the private data layer of the workflow; default: False

        Returns:
            Set of map keys (set)

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and isinstance(is_private, bool):
            return self._data_layer_operator.getMapKeys(mapname, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getMapKeys(mapname) accepts a string as &#39;mapname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def clearMap(self, mapname, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map to be cleared
            is_private (boolean): whether the map should be cleared in the private data layer of the workflow; default: False
            is_queued (boolean): whether the clear operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the clear operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.clearMap(mapname, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.clearMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def deleteMap(self, mapname, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map to be deleted
            is_private (boolean): whether the map should be deleted from the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.deleteMap(mapname, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.deleteMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def retrieveMap(self, mapname, is_private=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map to be retrieved
            is_private (boolean): whether the map should be retrieved from the private data layer of the workflow; default: False

        Returns:
            Map of data items as a collection of (key, value) pairs (dict)

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and isinstance(is_private, bool):
            return self._data_layer_operator.retrieveMap(mapname, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.retrieveMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getMapNames(self, start_index=0, end_index=2147483647, is_private=False):
        &#39;&#39;&#39;
        Args:
            start_index (int): the starting index of the map names to be retrieved; default: 0
            end_index (int): the end index of the map names to be retrieved; default: 2147483647
            is_private (boolean): whether the map names should be retrieved from the private data layer of the workflow; default: False

        Returns:
            List of map names (list)

        Raises:
            MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

        &#39;&#39;&#39;
        if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
            return self._data_layer_operator.getMapNames(start_index, end_index, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getMapNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    # set operations sanity checking
    def createSet(self, setname, is_private=False, is_queued=False):
        # _XXX_: the backend at the data layer does not create
        # sets and maps (i.e., createSet, createMap) until an entry is made
        # the addition of the entries will succeed without requiring the
        # corresponding set/map to have been created.
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set to be created
            is_private (boolean): whether the set should be created in the private data layer of the workflow; default: False
            is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the create operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the setname is not a string.

        &#39;&#39;&#39;
        self._logger.warning(&#34;MicroFunctionsAPI.createSet() does not have an effect; it will be removed in the future.&#34;)
        self._logger.warning(&#34;(Items can still be added without calling createSet() beforehand.)&#34;)
        return
        #if py3utils.is_string(setname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        #    self._data_layer_operator.createSet(setname, is_private, is_queued)
        #else:
        #    errmsg = &#34;MicroFunctionsAPI.createSet(setname) accepts a string as &#39;setname&#39;.&#34;
        #    errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        #    raise MicroFunctionsDataLayerException(errmsg)

    def addSetEntry(self, setname, item, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set
            item (string): the item to be added to the set
            is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
            is_queued (boolean): whether the add operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the add operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when any of setname and item is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.addSetEntry(setname, item, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.addSetEntry(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def removeSetEntry(self, setname, item, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set
            item (string): the item to be removed from the set
            is_private (boolean): whether the item should be removed from the private data layer of the workflow; default: False
            is_queued (boolean): whether the remove operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the remove operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when any of setname and item is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.removeSetEntry(setname, item, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.removeSetEntry(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def containsSetItem(self, setname, item, is_private=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set
            item (string): the item to be checked in the set
            is_private (boolean): whether the item should be checked in the private data layer of the workflow; default: False

        Returns:
            True if item exists in the set; False otherwise (boolean)

        Raises:
            MicroFunctionsDataLayerException: when any of setname and item is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool):
            return self._data_layer_operator.containsSetItem(setname, item, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.containsSetItem(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def retrieveSet(self, setname, is_private=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set to be retrieved
            is_private (boolean): whether the set should be retrieved from the private data layer of the workflow; default: False

        Returns:
            Set of set items (set)

        Raises:
            MicroFunctionsDataLayerException: when the setname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and isinstance(is_private, bool):
            return self._data_layer_operator.retrieveSet(setname, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.retrieveSet(setname) accepts a string as &#39;setname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def clearSet(self, setname, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set to be cleared
            is_private (boolean): whether the set should be cleared in the private data layer of the workflow; default: False
            is_queued (boolean): whether the clear operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the clear operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the setname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.clearSet(setname, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.clearSet(setname) accepts a string as &#39;setname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def deleteSet(self, setname, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set to be deleted
            is_private (boolean): whether the set should be deleted from the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the setname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.deleteSet(setname, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.deleteSet(setname) accepts a string as &#39;setname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getSetNames(self, start_index=0, end_index=2147483647, is_private=False):
        &#39;&#39;&#39;
        Args:
            start_index (int): the starting index of the set names to be retrieved; default: 0
            end_index (int): the end index of the set names to be retrieved; default: 2147483647
            is_private (boolean): whether the set names should be retrieved from the private data layer of the workflow; default: False

        Returns:
            List of set names (list)

        Raises:
            MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

        &#39;&#39;&#39;
        if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
            return self._data_layer_operator.getSetNames(start_index, end_index, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getSetNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    # counter operations sanity checking
    def createCounter(self, countername, count, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter to be created
            count (int): the initial value of the counter
            is_private (boolean): whether the counter should be created in the private data layer of the workflow; default: False
            is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the create operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string and/or the initial count is not an integer.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(count, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.createCounter(countername, count, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.createCounter(countername, count) accepts a string as &#39;countername&#39; and an integer as &#39;count&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getCounterValue(self, countername, is_private=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter whose value is to be retrieved
            is_private (boolean): whether the counter should be retrieved from the private data layer of the workflow; default: False

        Returns:
            The current value of the counter (int), or None if the counter does not exist.

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(is_private, bool):
            return self._data_layer_operator.getCounterValue(countername, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getCounterValue(countername) accepts a string as &#39;countername&#39;.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def incrementCounter(self, countername, increment, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter to be incremented
            increment (int): the value to be added to the counter
            is_private (boolean): whether the counter should be incremented in the private data layer of the workflow; default: False
            is_queued (boolean): whether the increment operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the increment operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string and/or the increment is not an integer.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(increment, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.incrementCounter(countername, increment, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.incrementCounter(countername, increment) accepts a string as &#39;countername&#39; and an integer as &#39;increment&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def decrementCounter(self, countername, decrement, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter to be decremented
            decrement (int): the value to be subtracted from the counter
            is_private (boolean): whether the counter should be decremented in the private data layer of the workflow; default: False
            is_queued (boolean): whether the decrement operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the decrement operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string and/or the decrement is not an integer.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(decrement, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.decrementCounter(countername, decrement, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.decrementCounter(countername, increment) accepts a string as &#39;countername&#39; and an integer as &#39;decrement&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def deleteCounter(self, countername, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter to be deleted
            is_private (boolean): whether the counter should be deleted in the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.deleteCounter(countername, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.deleteCounter(countername) accepts a string as &#39;countername&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getCounterNames(self, start_index=0, end_index=2147483647, is_private=False):
        &#39;&#39;&#39;
        Args:
            start_index (int): the starting index of the counter names to be retrieved; default: 0
            end_index (int): the end index of the counter names to be retrieved; default: 2147483647
            is_private (boolean): whether the counter names should be retrieved from the private data layer of the workflow; default: False

        Returns:
            List of counter names (list)

        Raises:
            MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

        &#39;&#39;&#39;
        if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
            return self._data_layer_operator.getCounterNames(start_index, end_index, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getCounterNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def get_transient_data_output(self, is_private=False):
        &#39;&#39;&#39;
        Return the transient data, so that it can be committed to the data layer
        when the function instance finishes.
        &#39;&#39;&#39;
        return self._data_layer_operator.get_transient_data_output(is_private)

    def get_data_to_be_deleted(self, is_private=False):
        &#39;&#39;&#39;
        Return the list of deleted data items, so that they can be committed to the data layer
        when the function instance finishes.
        &#39;&#39;&#39;
        return self._data_layer_operator.get_data_to_be_deleted(is_private)

    def _get_data_layer_client(self, is_private=False):
        &#39;&#39;&#39;
        Return the data layer client, so that it can be used to commit to the data layer
        when the function instance finishes.
        If it is not initialized yet, it will be initialized here.
        &#39;&#39;&#39;
        return self._data_layer_operator._get_data_layer_client(is_private)

    def _shutdown_data_layer_client(self):
        &#39;&#39;&#39;
        Shut down the data layer client if it has been initialized
        after the function instance finishes committing changes
        to the data layer.
        &#39;&#39;&#39;
        self._data_layer_operator._shutdown_data_layer_client()

    def addTriggerableTable(self, tableName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;addTriggerableTable&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;tablename&#34;: tableName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to add a triggerable table. &#34; + str(response))
            return False
        return True

    def addStorageTriggerForWorkflow(self, workflowName, tableName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;addStorageTriggerForWorkflow&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;workflowname&#34;: workflowName,
                &#34;tablename&#34;: tableName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to add a storage trigger for workflow &#34; + workflowName + &#34;, Triggerable table &#34; + tableName + &#34;, &#34; + str(response))
            return False
        return True

    def getWorkflowDetails(self, workflowName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;getWorkflowDetails&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;workflowname&#34;: workflowName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;email&#39;: &#39;...&#39;,
        #       &#39;name&#39;: &#39;...&#39;,
        #       &#39;id&#39;: &#39;...&#39;,
        #       &#39;status&#39;: &#39;...&#39;,
        #       &#39;endpoint&#39;: &#39;...&#39;,
        #       &#39;entry_topic&#39;: &#39;...&#39;,
        #       &#39;entry_grain&#39;: &#39;...&#39;,
        #       &#39;modified&#39;: &#39;...&#39;,
        #       &#39;associatedTriggerableTables&#39;: {
        #           &#39;&lt;table-name-1&gt;&#39;: &#39;&#39;, 
        #           &#39;&lt;table-name-2&gt;&#39;: &#39;&#39;, 
        #           ...
        #       }
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to fetch details for workflow: &#34; + workflowName + &#34;, error: &#34; + str(response))
        return response

    def deleteTriggerableTable(self, tableName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;deleteTriggerableTable&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;tablename&#34;: tableName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to delete a triggerable table. &#34; + str(response))
            return False
        return True

    def deleteStorageTriggerForWorkflow(self, workflowName, tableName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;deleteStorageTriggerForWorkflow&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;workflowname&#34;: workflowName,
                &#34;tablename&#34;: tableName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to delete a storage trigger for workflow &#34; + workflowName + &#34;, Triggerable table &#34; + tableName + &#34;, &#34; + str(response))
            return False
        return True

    def getTriggerableTables(self):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;getTriggerableTables&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken}
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #       &#39;tables&#39;: {
        #           &#39;&lt;table-name-1&gt;&#39;: [list of workflow names associated with &lt;table-name-1&gt;],
        #           &#39;&lt;table-name-2&gt;&#39;: [list of workflow names associated with &lt;table-name-2&gt;],
        #           ...
        #       }
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to fetch details for triggerable tables, error: &#34; + str(response))
        return response


    def invokeManagementAction(self, request):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        # request = \
        # {
        #     &#34;action&#34;: &#34;getWorkflowDetails&#34;,
        #     &#34;data&#34;: {
        #         &#34;user&#34;: {&#34;token&#34;: &#34;&#34;},
        #         &#34;&lt;other-stuff&gt;&#34;:
        #     }
        # }


        if &#34;action&#34; not in request or &#34;data&#34; not in request or &#34;user&#34; not in request[&#34;data&#34;] or &#34;token&#34; not in request[&#34;data&#34;][&#34;user&#34;]:
            return {&#34;status&#34;: &#34;failure&#34;, &#34;data&#34;: {&#34;message&#34;: &#34;Malformed request&#34;}}

        request[&#34;data&#34;][&#34;user&#34;][&#34;token&#34;] = _usertoken
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to invoke action: &#34; + request[&#34;action&#34;] + &#34;, error: &#34; + str(response))
        return response</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI"><code class="flex name class">
<span>class <span class="ident">MicroFunctionsAPI</span></span>
<span>(</span><span>uid, sid, wid, funcstatename, key, publication_utils, is_session_workflow, is_session_function, session_utils, logger, datalayer, nginx, useremail, usertoken)</span>
</code></dt>
<dd>
<section class="desc"><p>This class defines the API that is exposed to the user functions.
An object of this class is passed to the user function along with the input event.
It enables operations related to the following features:
- logging
- data layer access
- dynamic generation of workflows
- communication with other (sesssion or regular) functions during execution
- session customization</p>
<p>Initialize data structures for MicroFunctionsAPI object created for a function instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>uid</code></strong> :&ensp;<code>string</code></dt>
<dd>user id</dd>
<dt><strong><code>sid</code></strong> :&ensp;<code>string</code></dt>
<dd>sandbox id</dd>
<dt><strong><code>wid</code></strong> :&ensp;<code>string</code></dt>
<dd>workflow id</dd>
<dt><strong><code>logger</code></strong> :&ensp;<code>logger</code></dt>
<dd>log object</dd>
<dt><strong><code>funcstatename</code></strong> :&ensp;<code>string</code></dt>
<dd>function's state name</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>key of the input message</dd>
<dt><strong><code>datalayer</code></strong> :&ensp;<code>string</code></dt>
<dd>host:port of the local data layer server</dd>
<dt><strong><code>nginx</code></strong> :&ensp;<code>string</code></dt>
<dd>host:port of the mfn nginx server</dd>
<dt><strong><code>useremail</code></strong> :&ensp;<code>string</code></dt>
<dd>email address of the user</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MicroFunctionsAPI:
    &#39;&#39;&#39;
    This class defines the API that is exposed to the user functions.
    An object of this class is passed to the user function along with the input event.
    It enables operations related to the following features:
    - logging
    - data layer access
    - dynamic generation of workflows
    - communication with other (sesssion or regular) functions during execution
    - session customization
    &#39;&#39;&#39;
    def __init__(self, uid, sid, wid, funcstatename, key, publication_utils, is_session_workflow, is_session_function, session_utils, logger, datalayer, nginx, useremail, usertoken):
        &#39;&#39;&#39;
        Initialize data structures for MicroFunctionsAPI object created for a function instance.

        Args:
            uid (string): user id
            sid (string): sandbox id
            wid (string): workflow id
            logger (logger): log object
            funcstatename (string): function&#39;s state name
            key (string): key of the input message
            datalayer (string): host:port of the local data layer server
            nginx (string): host:port of the mfn nginx server
            useremail (string): email address of the user

        Returns:
            None
        &#39;&#39;&#39;

        self._logger = logger
        self._datalayer = datalayer
        self._nginx = nginx
        self._useremail = useremail
        self._usertoken = usertoken

        self._data_layer_operator = DataLayerOperator(uid, sid, wid, self._datalayer)

        # for sending immediate triggers to other functions
        self._publication_utils = publication_utils

        self._is_session_workflow = is_session_workflow
        self._is_session_function = is_session_function
        self._session_utils = session_utils

        self._function_state_name = funcstatename
        self._function_version = 1

        self._instanceid = key

        self._is_privileged = False
        if sid == &#34;SandService&#34; and wid == &#34;Management&#34;:
            self._is_privileged = True

        #self._logger.info(&#34;[MicroFunctionsAPI] init done.&#34;)

    def ping(self, num):
        self._logger.info(&#34;ping:&#34; + str(num))
        output = num
        return &#39;pong &#39; + str(output)

    def get_privileged_data_layer_client(self, suid=None, keyspace=None, tablename=None, maptablename=None, settablename=None, countertablename=None, init_tables=False):
        if self._is_privileged:
            if suid is not None:
                return DataLayerClient(locality=1, suid=suid, connect=self._datalayer, init_tables=init_tables)
            elif keyspace is not None and tablename is not None:
                dlc = DataLayerClient(locality=1, for_mfn=True, connect=self._datalayer)
                dlc.keyspace = keyspace
                dlc.tablename = tablename
                if maptablename is not None:
                    dlc.maptablename = maptablename
                if settablename is not None:
                    dlc.settablename = settablename
                if countertablename is not None:
                    dlc.countertablename = countertablename
                return dlc
        return None

    def update_metadata(self, metadata_name, metadata_value, is_privileged_metadata=False):
        is_privileged = False
        if is_privileged_metadata and self._is_privileged:
            is_privileged = True

        self._publication_utils.update_metadata(metadata_name, metadata_value, is_privileged=is_privileged)

    # session related API calls
    # only valid if the workflow has at least one session function
    def send_to_running_function_in_session(self, rgid, message, send_now=False):
        &#39;&#39;&#39;
        Send a message to a long-running session function instance identified with its id in this session.

        Args:
            rgid (string): the running long-running session function instance&#39;s id.
            message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
            send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

        Returns:
            None

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        message = self._publication_utils.convert_api_message_to_python_object(message)

        if not self._publication_utils.is_valid_value(message):
            errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
            raise MicroFunctionsSessionAPIException(errmsg)

        if self._is_session_workflow:
            self._session_utils.send_to_running_function_in_session(rgid, message, send_now)
        else:
            self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)

    def send_to_all_running_functions_in_session_with_function_name(self, gname, message, send_now=False):
        &#39;&#39;&#39;
        Send a message to all long-running session function instances identified with their function name in this session.
        There can be multiple instances with the same function name, which will all receive the message.
        The function name refers to the function name;
        it is not to be confused with the &#39;alias&#39; that may have been assigned to each long-running, session function instance.

        Args:
            gname (string): the function name (i.e., function name) of the running long-running session function instance(s).
            message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
            send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

        Returns:
            None

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        message = self._publication_utils.convert_api_message_to_python_object(message)

        if not self._publication_utils.is_valid_value(message):
            errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
            raise MicroFunctionsSessionAPIException(errmsg)

        if self._is_session_workflow:
            self._session_utils.send_to_all_running_functions_in_session_with_function_name(gname, message, send_now)
        else:
            self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)

    def send_to_all_running_functions_in_session(self, message, send_now=False):
        &#39;&#39;&#39;
        Send a message to all long-running session function instances in this session.

        Args:
            message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
            send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

        Returns:
            None

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        message = self._publication_utils.convert_api_message_to_python_object(message)

        if not self._publication_utils.is_valid_value(message):
            errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
            raise MicroFunctionsSessionAPIException(errmsg)

        if self._is_session_workflow:
            self._session_utils.send_to_all_running_functions_in_session(message, send_now)
        else:
            self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)

    def send_to_running_function_in_session_with_alias(self, alias, message, send_now=False):
        &#39;&#39;&#39;
        Send a message to a long-running session function instance identified with its alias in this session.
        The alias would have to be assigned before calling this function.
        The alias can belong to only a single long-running, session function instance.

        Args:
            alias (string): the alias of the running long-running session function instance that is the destination of the message.
            message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
            send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

        Returns:
            None

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        message = self._publication_utils.convert_api_message_to_python_object(message)

        if not self._publication_utils.is_valid_value(message):
            errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
            raise MicroFunctionsSessionAPIException(errmsg)

        if self._is_session_workflow:
            self._session_utils.send_to_running_function_in_session_with_alias(alias, message, send_now)
        else:
            self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)

    def get_session_update_messages(self, count=1):
        &#39;&#39;&#39;
        Retrieve the list of update messages sent to a session function instance.
        The list contains messages that were sent and delivered since the last time the session function instance has retrieved it.
        These messages are retrieved via a local queue. There can be more than one message.
        The optional count argument specifies how many messages should be retrieved.
        If there are fewer messages than the requested count, all messages will be retrieved and returned.

        Args:
            count (int): the number of messages to retrieve; default: 1

        Returns:
            List of messages that were sent to the session function instance.

        Warns:
            When the calling function is not a session function.

        &#39;&#39;&#39;
        messages = []
        if self._is_session_function:
            #self._logger.info(&#34;[MicroFunctionsAPI] getting session update messages...&#34;)
            messages = self._session_utils.get_session_update_messages_with_local_queue(count)
        else:
            self._logger.warning(&#34;Cannot get session update messages in a non-session function: &#34; + self._function_state_name)

        return messages

    def set_session_alias(self, alias):
        &#39;&#39;&#39;
        Assign an alias to the current session.

        Args:
            alias (string): the custom name to be assigned to the session.

        Returns:
            None

        Raises:
            MicroFunctionsSessionAPIException: when the alias is not a string, or is empty string.

        Warns:
            When the alias is already in use by another session.

        &#39;&#39;&#39;
        if not py3utils.is_string(alias) or alias == &#34;&#34;:
            raise MicroFunctionsSessionAPIException(&#34;Invalid session alias; must be a non-empty string.&#34;)
        elif alias == &#34;&#34;:
            raise MicroFunctionsSessionAPIException(&#34;Session alias cannot be empty.&#34;)

        if self._is_session_workflow:
            self._session_utils.set_session_alias(alias)
        else:
            self._logger.warning(&#34;Cannot set a session alias in a workflow with no session functions.&#34;)

    def unset_session_alias(self):
        &#39;&#39;&#39;
        Remove the existing alias of the current session.

        Args:
            None

        Returns:
            None

        &#39;&#39;&#39;
        self._session_utils.unset_session_alias()

    def get_session_alias(self):
        &#39;&#39;&#39;
        Retrieve the existing alias of the current session.

        Args:
            None

        Returns:
            The existing session alias (string) or None if no alias is set.

        &#39;&#39;&#39;
        if self._is_session_workflow:
            return self._session_utils.get_session_alias()
        else:
            self._logger.warning(&#34;Cannot get a session alias in a workflow with no session functions.&#34;)
        return None

    def set_session_function_alias(self, alias, session_function_id=None):
        &#39;&#39;&#39;
        Assign an alias to a session function instance in this session.
        If the session function id is not set, the alias will be assigned to the calling function instance.
        If it is set, the alias will be assigned to the function instance with the given id.

        Args:
            alias (string): the custom name to be assigned to the session function instance.
            session_function_id (string): the session function instance id for which this alias should be assigned; default: None

        Returns:
            None

        Raises:
            MicroFunctionsSessionAPIException: when the alias is not a string, or is empty string

        Warns:
            When calling function is not a session function.
            When no session function instance exists with the given session function id.
            When the alias is already in use by another existing session function instance.

        &#39;&#39;&#39;
        if not py3utils.is_string(alias):
            raise MicroFunctionsSessionAPIException(&#34;Invalid session function alias; must be a non-empty string.&#34;)
        elif alias == &#34;&#34;:
            raise MicroFunctionsSessionAPIException(&#34;Session function alias cannot be empty.&#34;)

        # handle another session function&#39;s alias
        if session_function_id is not None:
            self._session_utils.set_session_function_alias(alias, session_function_id)
        elif self._is_session_function:
            self._session_utils.set_session_function_alias(alias)
        else:
            self._logger.warning(&#34;Cannot set a session function alias in a non-session function.&#34;)

    def unset_session_function_alias(self, session_function_id=None):
        &#39;&#39;&#39;
        Remove the current alias of the session function instance in this session.
        If the session function id is not set, the current function instance&#39;s alias will be removed.
        If it is set, the alias of the session function instance corresponding to the id will be removed.

        Args:
            session_function_id (string): the id of the session function instance whose alias should be removed; default: None.

        Returns:
            None

        Warns:
            When calling function is not a session function if session function id is None.
            When no session function instance exists with the given session function id.

        &#39;&#39;&#39;
        # handle another session function&#39;s alias
        if session_function_id is not None:
            self._session_utils.unset_session_function_alias(session_function_id)
        elif self._is_session_function:
            self._session_utils.unset_session_function_alias()
        else:
            self._logger.warning(&#34;Cannot unset a session function alias in a non-session function.&#34;)

    def get_session_function_alias(self, session_function_id=None):
        &#39;&#39;&#39;
        Retrieve the current alias of the session function instance in this session.
        If the session function id is not set, the current function instance&#39;s alias will be retrieved.
        If it is set, the alias of the session function instance corresponding to the id will be retrieved.

        Args:
            session_function_id (string): the id of the session function instance whose alias should be retrieved; default: None.

        Returns:
            The existing alias of the session function instance (string) or None if no alias is set.

        Warns:
            When calling function is not a session function if session function id is None.
            When no session function instance exists with the given session function id.

        &#39;&#39;&#39;
        # handle another session function&#39;s alias
        if session_function_id is not None:
            return self._session_utils.get_session_function_alias(session_function_id)
        elif self._is_session_function:
            return self._session_utils.get_session_function_alias()
        else:
            self._logger.warning(&#34;Cannot get a session function alias in a non-session function.&#34;)
        return None

    def get_all_session_function_aliases(self):
        &#39;&#39;&#39;
        Retrieve the session function instance and alias mapping for all the session function instances in this session.

        Args:
            None

        Returns:
            A dictionary with session function instance id as the key and the alias as the value involving all session function instances in this session.

        Warns:
            When the calling function is not part of a workflow with at least one session function.

        &#39;&#39;&#39;
        aliases = {}
        if self._is_session_workflow:
            aliases = self._session_utils.get_all_session_function_aliases()
        else:
            self._logger.warning(&#34;Cannot get session function aliases in a workflow with no session functions.&#34;)
        return aliases

    def get_alias_summary(self):
        &#39;&#39;&#39;
        Retrieve a summary of the aliases of the current session and its session function instances.

        Args:
            None

        Returns:
            Dictionary with two keys -- &#39;session&#39; and &#39;session_functions&#39;, each referring to another dictionary.
            &#39;session&#39; dictionary will have an item with the session id as the key and the session alias as the value.
            &#39;session_functions&#39; dictionary will have one or more entries, where each key will be the id of a session function instance
            and the corresponding value will be the alias assigned to that session function instance.
            If any alias is not set, then the values will be None.

        Warns:
            When the calling function is not part of a workflow with at least one session function.

        &#39;&#39;&#39;
        alias_summary = {}
        if self._is_session_workflow:
            alias_summary = self._session_utils.get_alias_summary()
        else:
            self._logger.warning(&#34;Cannot get alias summary for session in a workflow with no session functions.&#34;)
        return alias_summary

    def get_session_id(self):
        &#39;&#39;&#39;
        Retrieve the current session&#39;s id.

        Args:
            None

        Returns:
            The session id of the current session.

        Warns:
            When the calling function is not part of a workflow with at least one session function.

        &#39;&#39;&#39;
        if self._is_session_workflow:
            return self._session_utils.get_session_id()
        else:
            self._logger.warning(&#34;Cannot get a session id in a workflow with no session functions.&#34;)
        return None

    def get_session_function_id(self):
        &#39;&#39;&#39;
        Retrieve the current session function instance&#39;s id.

        Args:
            None

        Returns:
            The id of the current session function instance.

        Warns:
            When the calling function is not a session function.

        &#39;&#39;&#39;
        if self._is_session_function:
            return self._session_utils.get_session_function_id()
        else:
            self._logger.warning(&#34;Cannot get session function id in a non-session function.&#34;)
        return None

    def get_session_function_id_with_alias(self, alias=None):
        &#39;&#39;&#39;
        Retrieve the id of a session function instance using an alias.
        When alias is not set, the id of the current session function instance will be returned.
        When it is not set, the id of the session function instance with that alias will be returned.

        Args:
            alias (string): The alias that needs to be used to retrieve the id of the session function instance; default: None

        Returns:
            The id of the current session function instance when alias is not set, or the ide of the session function instance with the given alias.

        Warns:
            When the calling function is not a session function if the alias is not given.

        &#39;&#39;&#39;
        # handle another session function&#39;s alias
        if alias is not None:
            return self._session_utils.get_session_function_id_with_alias(alias)
        elif self._is_session_function:
            return self._session_utils.get_session_function_id_with_alias()
        else:
            self._logger.warning(&#34;Cannot get session function id in a non-session function.&#34;)
        return None

    def get_all_session_function_ids(self):
        &#39;&#39;&#39;
        Retrieve a list of all ids of the session function instances in this session.

        Args:
            None

        Returns:
            List of ids of all the session function instances in this session.

        Warns:
            When the calling function is not part of a workflow with at least one session function.

        &#39;&#39;&#39;
        rgidlist = []
        if self._is_session_workflow:
            rgidlist = self._session_utils.get_all_session_function_ids()
        else:
            self._logger.warning(&#34;Cannot get session function ids in a workflow with no session functions.&#34;)
        return rgidlist

    def is_still_running(self):
        &#39;&#39;&#39;
        Retrieve the status of this session function instance.
        The status of the session function instance could have been changed via a special message
        delivered to the session function instance and handled by the platform.
        A session function should call this method to handle such cases.

        Args:
            None

        Returns:
            True if the session function instance has not received a special message to stop, or False otherwise.

        Warns:
            When the calling function is not a session function.

        &#39;&#39;&#39;
        if self._is_session_function:
            return self._session_utils.is_session_function_running()
        else:
            self._logger.warning(&#34;Cannot get status of running in a non-session function.&#34;)
        return None

    ##########################
    # _XXX_: API call changes:
    # 1. for better function names that reflect the intention (e.g., add_workflow_next)
    # 2. new API call for sending immediate messages
    # 2.1 need to get a list of functions in this sandbox for sanity checking
    # (i.e., messages should only be sent to functions listed in this sandbox)
    # 3. better checking of _wf_pot_next
    # (i.e., when adding a dynamic trigger rather than publishing at the end of execution)
    # 4. optimization of the trigger validity check
    def add_workflow_next(self, next, value):
        &#39;&#39;&#39;
        Construct a dynamic trigger and add it to the workflow.
        The dynamic trigger will define the next function to be executed after this function
        and the value that will be passed as input to the next function.
        If the &#39;value&#39; field is not used, the &#39;next&#39; function will be executed with an empty string as input.

        Args:
            next (string): the function name to be executed after this function; must be of a string.
            value: the input value to be passed to the next function; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        Returns:
            None

        Raises:
            MicroFunctionsWorkflowException: when either &#39;next&#39; is not a string or &#39;value&#39; is not a valid python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        value = self._publication_utils.convert_api_message_to_python_object(value)

        is_valid, is_privileged, errmsg = self._publication_utils.is_valid_trigger_message(next, value, False)

        if is_valid:
            trigger = {}
            trigger[&#34;next&#34;] = next
            trigger[&#34;value&#34;] = value
            trigger[&#34;is_privileged&#34;] = is_privileged
            self._publication_utils.append_trigger(trigger)
        else:
            raise MicroFunctionsWorkflowException(errmsg)

    def add_dynamic_next(self, next, value):
        &#39;&#39;&#39;
        Alias for add_workflow_next(self, next, value).
        &#39;&#39;&#39;
        self.add_workflow_next(next, value)

    def send_to_function_now(self, destination, value):
        &#39;&#39;&#39;
        Send a new event message to another function immediately instead of waiting until the end of the current function execution.
        The destination can be any function in the workflow description.
        The value must be a python data type.

        Args:
            destination (string): the destination of the message
            value (*): message to be sent; must be a python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        Raises:
            MicroFunctionsWorkflowException: when either the destination is not a string or the value is not a python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        value = self._publication_utils.convert_api_message_to_python_object(value)

        is_valid, is_privileged, errmsg = self._publication_utils.is_valid_trigger_message(destination, value, True)

        if is_valid:
            trigger = {}
            trigger[&#34;next&#34;] = destination
            trigger[&#34;value&#34;] = value
            trigger[&#34;is_privileged&#34;] = is_privileged
            self._publication_utils.send_to_function_now(self._instanceid, trigger)
        else:
            raise MicroFunctionsWorkflowException(errmsg)

    #########################

    def add_dynamic_workflow(self, dynamic_trigger):
        &#39;&#39;&#39;
        Add dynamically generated trigger(s) to the workflow.
        The dynamically generated trigger can be a single dictionary with &#39;next&#39; and &#39;value&#39; fields,
        or a list of dictionaries with &#39;next&#39; and &#39;value&#39; fields.
        In each dictionary, the &#39;next&#39; field defines the next function that needs to be triggered.
        The &#39;value&#39; field defines the input to the respective next function.
        This function will check the validity of the dictionary and raise MicroFunctionsWorkflowException if either &#39;next&#39; is not a string or &#39;value&#39; is not a valid python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

        Args:
            dynamic_trigger (list of dicts, or dict): each dictionary must be of the form: {&#39;next&#39;: &lt;type &#39;str&#39;&gt;, &#39;value&#39;: &lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;}

        Returns:
            None

        Raises:
            MicroFunctionsWorkflowException: when the input is neither a list of dictionaries or a single dictionary.
            MicroFunctionsWorkflowException: when in a dictionary, &#39;next&#39; or &#39;value&#39; is missing.

        &#39;&#39;&#39;
        # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
        # we make the conversion according to the runtime
        dynamic_trigger = self._publication_utils.convert_api_message_to_python_object(dynamic_trigger)

        is_valid = True
        # &#39;dynamic_trigger&#39; can be a single dictionary or a list of dictionaries.
        # each dictionary must be of the form: {&#39;next&#39;: &lt;type &#39;str&#39;&gt;, &#39;value&#39;: &lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;}
        if isinstance(dynamic_trigger, dict):
            if &#39;next&#39; in dynamic_trigger and &#39;value&#39; in dynamic_trigger:
                self.add_workflow_next(dynamic_trigger[&#39;next&#39;], dynamic_trigger[&#39;value&#39;])
            else:
                errmsg = &#34;Malformed dynamic trigger definition; &#39;next&#39; and &#39;value&#39; must be present in the trigger dict().&#34;
                is_valid = False
        elif isinstance(dynamic_trigger, list):
            for trigger in dynamic_trigger:
                if &#39;next&#39; in trigger and &#39;value&#39; in trigger:
                    self.add_workflow_next(trigger[&#39;next&#39;], trigger[&#39;value&#39;])
                else:
                    errmsg = &#34;Malformed dynamic trigger definition; &#39;next&#39; and &#39;value&#39; must be present in the trigger dict().&#34;
                    is_valid = False
                    break
        else:
            errmsg = &#34;Malformed dynamic trigger definition; use either a dict() with &#39;next&#39; and &#39;value&#39; fields or a list of dict().&#34;
            is_valid = False

        if not is_valid:
            raise MicroFunctionsWorkflowException(errmsg)

    def get_dynamic_workflow(self):
        &#39;&#39;&#39;
        Return the dynamically generated workflow information,
        so that this function instance can trigger other functions when it finishes.
        &#39;&#39;&#39;
        return self._publication_utils.get_dynamic_workflow()

    #########################

    def get_remaining_time_in_millis(self):
        &#39;&#39;&#39;
        Return the remaining time this function instance is allowed to continue running.
        The time is returned in milliseconds.
        This function exists for AWS Lambda compatibility.
        As of 10.04.2018, the maximum time a function instance can execute is not limited.
        This will change in the future.
        &#39;&#39;&#39;
        # 5 minutes always
        return 300000

    def log(self, text, level=&#34;INFO&#34;):
        &#39;&#39;&#39;
        Log text. Uses the instance id to indicate which function instance logged the text.

        Args:
            text (string): text to be logged.
            level (string): log level to be used.
        Returns:
            None.

        Raises:
            MicroFunctionsUserLogException: when there are any errors in the logging function.
        &#39;&#39;&#39;

        if level == &#34;INFO&#34;:
            self._logger.info(text)
        elif level == &#34;WARNING&#34;:
            self._logger.warning(text)
        elif level == &#34;DEBUG&#34;:
            self._logger.debug(text)
        elif level == &#34;ERROR&#34;:
            self._logger.error(text)
        else:
            raise MicroFunctionsUserLogException(&#34;User logging exception; unsupported log level: &#34; + str(level))

    def get_event_key(self):
        &#39;&#39;&#39;
        Return the function instance id (i.e., the key of the trigger event).
        &#39;&#39;&#39;
        return self._instanceid


    def get_instance_id(self):
        &#39;&#39;&#39;
        Return the function instance id (i.e., the key of the trigger event).
        &#39;&#39;&#39;
        return self._instanceid

    def put(self, key, value, is_private=False, is_queued=False, tableName=None):
        &#39;&#39;&#39;
        Access to data layer to store a data item in the form of a (key, value) pair.
        By default, the put operation is reflected on the data layer immediately.
        If the put operation is queued (i.e., is_queued = True),
        the data item is put into the transient data table.
        If the key was previously deleted by the function instance,
        it is removed from the list of items to be deleted.
        When the function instance finishes,
        the transient data items are committed to the data layer.

        Args:
            key (string): the key of the data item
            value (string): the value of the data item
            is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
            is_queued (boolean): whether the put operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the put operation will be reflected on the data layer immediately)
            tableName (string): name of the table where to put the key. By default, it will be put in the default table.

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the key and/or value are not strings.
        &#39;&#39;&#39;
        if py3utils.is_string(key) and py3utils.is_string(value) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.put(key, value, is_private, is_queued, table=tableName)
        else:
            errmsg = &#34;MicroFunctionsAPI.put(key, value) accepts a string as &#39;key&#39; and &#39;value&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def get(self, key, is_private=False, tableName=None):
        &#39;&#39;&#39;
        Access to data layer to load the value of a given key.
        The key is first checked in the transient deleted items.
        If it is not deleted, the key is then checked in the transient data table.
        If it is not there, it is retrieved from the global data layer.
        As a result, the value returned is consistent with
        what this function instance does with the data item.
        If the data item is not present in either the transient data table
        nor in the global data layer, an empty string (i.e., &#34;&#34;) will be
        returned.
        If the function used put() and delete() operations with is_queued=False (default),
        then the checks of the transient table will result in empty values,
        so that the item will be retrieved from the global data layer.

        Args:
            key (string): the key of the data item
            is_private (boolean): whether the item should be read from the private data layer of the workflow; default: False
            tableName (string): name of the table where to get the key from. By default, it will be fetched from the default table.

        Returns:
            value (string): the value of the data item; empty string if the data item is not present.

        Raises:
            MicroFunctionsDataLayerException: when the key is not a string.
        &#39;&#39;&#39;
        # check first transient_output
        # if not there, return the actual (global) data layer data item
        # if not there either, return empty string (as defined in the DataLayerClient)
        if py3utils.is_string(key) and isinstance(is_private, bool):
            return self._data_layer_operator.get(key, is_private, table=tableName)
        else:
            errmsg = &#34;MicroFunctionsAPI.get(key) accepts a string as &#39;key&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def delete(self, key, is_private=False, is_queued=False, tableName=None):
        &#39;&#39;&#39;
        Alias for remove(key, is_private, is_queued, tableName).
        &#39;&#39;&#39;
        self.remove(key, is_private, is_queued, tableName)

    def remove(self, key, is_private=False, is_queued=False, tableName=None):
        &#39;&#39;&#39;
        Access to data layer to remove data item associated with a given key.
        By default, the remove operation is reflected on the data layer immediately.
        If the delete operation is queued (i.e., is_queued = True),
        the key is removed from the transient data table.
        It is also added to the list of items to be deleted from the global
        data layer when the function instance finishes.

        Args:
            key (string): the key of the data item
            is_private (boolean): whether the item should be deleted from the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)
            tableName (string): name of the table where to remove the key from. By default, it will be deleted from the default table.

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the key is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(key) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.delete(key, is_private, is_queued, table=tableName)
        else:
            errmsg = &#34;MicroFunctionsAPI.delete(key) accepts a string as &#39;key&#39;&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    # map operations sanity checking
    def createMap(self, mapname, is_private=False, is_queued=False):
        # _XXX_: the backend at the data layer does not create
        # sets and maps (i.e., createSet, createMap) until an entry is made
        # the addition of the entries will succeed without requiring the
        # corresponding set/map to have been created.
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map to be created
            is_private (boolean): whether the map should be created in the private data layer of the workflow; default: False
            is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the create operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        self._logger.warning(&#34;MicroFunctionsAPI.createMap() does not have an effect; it will be removed in the future.&#34;)
        self._logger.warning(&#34;(Entries can still be added without calling createMap() beforehand.)&#34;)
        return
        #if py3utils.is_string(mapname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        #    self._data_layer_operator.createMap(mapname, is_private, is_queued)
        #else:
        #    errmsg = &#34;MicroFunctionsAPI.createMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
        #    errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        #    raise MicroFunctionsDataLayerException(errmsg)

    def putMapEntry(self, mapname, key, value, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map
            key (string): the key of the data item
            value (string): the value of the data item
            is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
            is_queued (boolean): whether the put operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the put operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when any of mapname, key and value is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and py3utils.is_string(key) and py3utils.is_string(value) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.putMapEntry(mapname, key, value, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.putMapEntry(mapname, key, value) accepts a string as &#39;mapname&#39;, &#39;key&#39; and &#39;value&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getMapEntry(self, mapname, key, is_private=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map
            key (string): the key of the data item
            is_private (boolean): whether the item should be retrieved from the private data layer of the workflow; default: False

        Returns:
            The value associated with the key in the map (string), or empty string &#34;&#34; if the key does not exist.

        Raises:
            MicroFunctionsDataLayerException: when any of mapname and key is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool):
            return self._data_layer_operator.getMapEntry(mapname, key, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getMapEntry(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def deleteMapEntry(self, mapname, key, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map
            key (string): the key of the data item
            is_private (boolean): whether the item should be deleted from the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when any of mapname and key is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.deleteMapEntry(mapname, key, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.deleteMapEntry(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def containsMapKey(self, mapname, key, is_private=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map
            key (string): the key of the data item
            is_private (boolean): whether the map should be checked in the private data layer of the workflow; default: False

        Returns:
            True if key exists in the map; False otherwise (boolean)

        Raises:
            MicroFunctionsDataLayerException: when any of mapname and key is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool):
            return self._data_layer_operator.containsMapKey(mapname, key, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.containsMapKey(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getMapKeys(self, mapname, is_private=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map whose keys are to be retrieved
            is_private (boolean): whether the map should be retrieved from the private data layer of the workflow; default: False

        Returns:
            Set of map keys (set)

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and isinstance(is_private, bool):
            return self._data_layer_operator.getMapKeys(mapname, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getMapKeys(mapname) accepts a string as &#39;mapname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def clearMap(self, mapname, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map to be cleared
            is_private (boolean): whether the map should be cleared in the private data layer of the workflow; default: False
            is_queued (boolean): whether the clear operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the clear operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.clearMap(mapname, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.clearMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def deleteMap(self, mapname, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map to be deleted
            is_private (boolean): whether the map should be deleted from the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.deleteMap(mapname, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.deleteMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def retrieveMap(self, mapname, is_private=False):
        &#39;&#39;&#39;
        Args:
            mapname (string): the name of the map to be retrieved
            is_private (boolean): whether the map should be retrieved from the private data layer of the workflow; default: False

        Returns:
            Map of data items as a collection of (key, value) pairs (dict)

        Raises:
            MicroFunctionsDataLayerException: when the mapname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(mapname) and isinstance(is_private, bool):
            return self._data_layer_operator.retrieveMap(mapname, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.retrieveMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getMapNames(self, start_index=0, end_index=2147483647, is_private=False):
        &#39;&#39;&#39;
        Args:
            start_index (int): the starting index of the map names to be retrieved; default: 0
            end_index (int): the end index of the map names to be retrieved; default: 2147483647
            is_private (boolean): whether the map names should be retrieved from the private data layer of the workflow; default: False

        Returns:
            List of map names (list)

        Raises:
            MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

        &#39;&#39;&#39;
        if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
            return self._data_layer_operator.getMapNames(start_index, end_index, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getMapNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    # set operations sanity checking
    def createSet(self, setname, is_private=False, is_queued=False):
        # _XXX_: the backend at the data layer does not create
        # sets and maps (i.e., createSet, createMap) until an entry is made
        # the addition of the entries will succeed without requiring the
        # corresponding set/map to have been created.
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set to be created
            is_private (boolean): whether the set should be created in the private data layer of the workflow; default: False
            is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the create operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the setname is not a string.

        &#39;&#39;&#39;
        self._logger.warning(&#34;MicroFunctionsAPI.createSet() does not have an effect; it will be removed in the future.&#34;)
        self._logger.warning(&#34;(Items can still be added without calling createSet() beforehand.)&#34;)
        return
        #if py3utils.is_string(setname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        #    self._data_layer_operator.createSet(setname, is_private, is_queued)
        #else:
        #    errmsg = &#34;MicroFunctionsAPI.createSet(setname) accepts a string as &#39;setname&#39;.&#34;
        #    errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        #    raise MicroFunctionsDataLayerException(errmsg)

    def addSetEntry(self, setname, item, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set
            item (string): the item to be added to the set
            is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
            is_queued (boolean): whether the add operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the add operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when any of setname and item is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.addSetEntry(setname, item, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.addSetEntry(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def removeSetEntry(self, setname, item, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set
            item (string): the item to be removed from the set
            is_private (boolean): whether the item should be removed from the private data layer of the workflow; default: False
            is_queued (boolean): whether the remove operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the remove operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when any of setname and item is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.removeSetEntry(setname, item, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.removeSetEntry(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def containsSetItem(self, setname, item, is_private=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set
            item (string): the item to be checked in the set
            is_private (boolean): whether the item should be checked in the private data layer of the workflow; default: False

        Returns:
            True if item exists in the set; False otherwise (boolean)

        Raises:
            MicroFunctionsDataLayerException: when any of setname and item is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool):
            return self._data_layer_operator.containsSetItem(setname, item, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.containsSetItem(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def retrieveSet(self, setname, is_private=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set to be retrieved
            is_private (boolean): whether the set should be retrieved from the private data layer of the workflow; default: False

        Returns:
            Set of set items (set)

        Raises:
            MicroFunctionsDataLayerException: when the setname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and isinstance(is_private, bool):
            return self._data_layer_operator.retrieveSet(setname, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.retrieveSet(setname) accepts a string as &#39;setname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def clearSet(self, setname, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set to be cleared
            is_private (boolean): whether the set should be cleared in the private data layer of the workflow; default: False
            is_queued (boolean): whether the clear operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the clear operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the setname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.clearSet(setname, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.clearSet(setname) accepts a string as &#39;setname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def deleteSet(self, setname, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            setname (string): the name of the set to be deleted
            is_private (boolean): whether the set should be deleted from the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the setname is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(setname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.deleteSet(setname, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.deleteSet(setname) accepts a string as &#39;setname&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getSetNames(self, start_index=0, end_index=2147483647, is_private=False):
        &#39;&#39;&#39;
        Args:
            start_index (int): the starting index of the set names to be retrieved; default: 0
            end_index (int): the end index of the set names to be retrieved; default: 2147483647
            is_private (boolean): whether the set names should be retrieved from the private data layer of the workflow; default: False

        Returns:
            List of set names (list)

        Raises:
            MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

        &#39;&#39;&#39;
        if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
            return self._data_layer_operator.getSetNames(start_index, end_index, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getSetNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    # counter operations sanity checking
    def createCounter(self, countername, count, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter to be created
            count (int): the initial value of the counter
            is_private (boolean): whether the counter should be created in the private data layer of the workflow; default: False
            is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the create operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string and/or the initial count is not an integer.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(count, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.createCounter(countername, count, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.createCounter(countername, count) accepts a string as &#39;countername&#39; and an integer as &#39;count&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getCounterValue(self, countername, is_private=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter whose value is to be retrieved
            is_private (boolean): whether the counter should be retrieved from the private data layer of the workflow; default: False

        Returns:
            The current value of the counter (int), or None if the counter does not exist.

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(is_private, bool):
            return self._data_layer_operator.getCounterValue(countername, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getCounterValue(countername) accepts a string as &#39;countername&#39;.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def incrementCounter(self, countername, increment, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter to be incremented
            increment (int): the value to be added to the counter
            is_private (boolean): whether the counter should be incremented in the private data layer of the workflow; default: False
            is_queued (boolean): whether the increment operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the increment operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string and/or the increment is not an integer.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(increment, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.incrementCounter(countername, increment, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.incrementCounter(countername, increment) accepts a string as &#39;countername&#39; and an integer as &#39;increment&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def decrementCounter(self, countername, decrement, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter to be decremented
            decrement (int): the value to be subtracted from the counter
            is_private (boolean): whether the counter should be decremented in the private data layer of the workflow; default: False
            is_queued (boolean): whether the decrement operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the decrement operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string and/or the decrement is not an integer.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(decrement, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.decrementCounter(countername, decrement, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.decrementCounter(countername, increment) accepts a string as &#39;countername&#39; and an integer as &#39;decrement&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def deleteCounter(self, countername, is_private=False, is_queued=False):
        &#39;&#39;&#39;
        Args:
            countername (string): the name of the counter to be deleted
            is_private (boolean): whether the counter should be deleted in the private data layer of the workflow; default: False
            is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
                (i.e., the delete operation will be reflected on the data layer immediately)

        Returns:
            None

        Raises:
            MicroFunctionsDataLayerException: when the countername is not a string.

        &#39;&#39;&#39;
        if py3utils.is_string(countername) and isinstance(is_private, bool) and isinstance(is_queued, bool):
            self._data_layer_operator.deleteCounter(countername, is_private, is_queued)
        else:
            errmsg = &#34;MicroFunctionsAPI.deleteCounter(countername) accepts a string as &#39;countername&#39;.&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def getCounterNames(self, start_index=0, end_index=2147483647, is_private=False):
        &#39;&#39;&#39;
        Args:
            start_index (int): the starting index of the counter names to be retrieved; default: 0
            end_index (int): the end index of the counter names to be retrieved; default: 2147483647
            is_private (boolean): whether the counter names should be retrieved from the private data layer of the workflow; default: False

        Returns:
            List of counter names (list)

        Raises:
            MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

        &#39;&#39;&#39;
        if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
            return self._data_layer_operator.getCounterNames(start_index, end_index, is_private)
        else:
            errmsg = &#34;MicroFunctionsAPI.getCounterNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
            errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
            raise MicroFunctionsDataLayerException(errmsg)

    def get_transient_data_output(self, is_private=False):
        &#39;&#39;&#39;
        Return the transient data, so that it can be committed to the data layer
        when the function instance finishes.
        &#39;&#39;&#39;
        return self._data_layer_operator.get_transient_data_output(is_private)

    def get_data_to_be_deleted(self, is_private=False):
        &#39;&#39;&#39;
        Return the list of deleted data items, so that they can be committed to the data layer
        when the function instance finishes.
        &#39;&#39;&#39;
        return self._data_layer_operator.get_data_to_be_deleted(is_private)

    def _get_data_layer_client(self, is_private=False):
        &#39;&#39;&#39;
        Return the data layer client, so that it can be used to commit to the data layer
        when the function instance finishes.
        If it is not initialized yet, it will be initialized here.
        &#39;&#39;&#39;
        return self._data_layer_operator._get_data_layer_client(is_private)

    def _shutdown_data_layer_client(self):
        &#39;&#39;&#39;
        Shut down the data layer client if it has been initialized
        after the function instance finishes committing changes
        to the data layer.
        &#39;&#39;&#39;
        self._data_layer_operator._shutdown_data_layer_client()

    def addTriggerableTable(self, tableName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;addTriggerableTable&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;tablename&#34;: tableName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to add a triggerable table. &#34; + str(response))
            return False
        return True

    def addStorageTriggerForWorkflow(self, workflowName, tableName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;addStorageTriggerForWorkflow&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;workflowname&#34;: workflowName,
                &#34;tablename&#34;: tableName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to add a storage trigger for workflow &#34; + workflowName + &#34;, Triggerable table &#34; + tableName + &#34;, &#34; + str(response))
            return False
        return True

    def getWorkflowDetails(self, workflowName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;getWorkflowDetails&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;workflowname&#34;: workflowName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;email&#39;: &#39;...&#39;,
        #       &#39;name&#39;: &#39;...&#39;,
        #       &#39;id&#39;: &#39;...&#39;,
        #       &#39;status&#39;: &#39;...&#39;,
        #       &#39;endpoint&#39;: &#39;...&#39;,
        #       &#39;entry_topic&#39;: &#39;...&#39;,
        #       &#39;entry_grain&#39;: &#39;...&#39;,
        #       &#39;modified&#39;: &#39;...&#39;,
        #       &#39;associatedTriggerableTables&#39;: {
        #           &#39;&lt;table-name-1&gt;&#39;: &#39;&#39;, 
        #           &#39;&lt;table-name-2&gt;&#39;: &#39;&#39;, 
        #           ...
        #       }
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to fetch details for workflow: &#34; + workflowName + &#34;, error: &#34; + str(response))
        return response

    def deleteTriggerableTable(self, tableName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;deleteTriggerableTable&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;tablename&#34;: tableName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to delete a triggerable table. &#34; + str(response))
            return False
        return True

    def deleteStorageTriggerForWorkflow(self, workflowName, tableName):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;deleteStorageTriggerForWorkflow&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken},
                &#34;workflowname&#34;: workflowName,
                &#34;tablename&#34;: tableName
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to delete a storage trigger for workflow &#34; + workflowName + &#34;, Triggerable table &#34; + tableName + &#34;, &#34; + str(response))
            return False
        return True

    def getTriggerableTables(self):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        request = \
        {
            &#34;action&#34;: &#34;getTriggerableTables&#34;,
            &#34;data&#34;: {
                &#34;user&#34;: {&#34;token&#34;: _usertoken}
            }
        }
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #       &#39;tables&#39;: {
        #           &#39;&lt;table-name-1&gt;&#39;: [list of workflow names associated with &lt;table-name-1&gt;],
        #           &#39;&lt;table-name-2&gt;&#39;: [list of workflow names associated with &lt;table-name-2&gt;],
        #           ...
        #       }
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to fetch details for triggerable tables, error: &#34; + str(response))
        return response


    def invokeManagementAction(self, request):
        _nginx = self._nginx
        _useremail = self._useremail
        _usertoken = self._usertoken
        _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

        # request = \
        # {
        #     &#34;action&#34;: &#34;getWorkflowDetails&#34;,
        #     &#34;data&#34;: {
        #         &#34;user&#34;: {&#34;token&#34;: &#34;&#34;},
        #         &#34;&lt;other-stuff&gt;&#34;:
        #     }
        # }


        if &#34;action&#34; not in request or &#34;data&#34; not in request or &#34;user&#34; not in request[&#34;data&#34;] or &#34;token&#34; not in request[&#34;data&#34;][&#34;user&#34;]:
            return {&#34;status&#34;: &#34;failure&#34;, &#34;data&#34;: {&#34;message&#34;: &#34;Malformed request&#34;}}

        request[&#34;data&#34;][&#34;user&#34;][&#34;token&#34;] = _usertoken
        r = requests.post(_url, json=request, verify=False)
        #print(r.text)
        response = json.loads(r.text)
        # {
        #   &#39;status&#39;: &#39;success&#39;, 
        #   &#39;data&#39;: {
        #       &#39;message&#39;: &#39;...&#39;,
        #   }
        # }
        if response[&#34;status&#34;] != &#39;success&#39;:
            print(&#34;Unable to invoke action: &#34; + request[&#34;action&#34;] + &#34;, error: &#34; + str(response))
        return response</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.addSetEntry"><code class="name flex">
<span>def <span class="ident">addSetEntry</span></span>(<span>self, setname, item, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>setname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the set</dd>
<dt><strong><code>item</code></strong> :&ensp;<code>string</code></dt>
<dd>the item to be added to the set</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be written to the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the add operation should be reflected on the data layer after the execution finish; default: False
(i.e., the add operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when any of setname and item is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addSetEntry(self, setname, item, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        setname (string): the name of the set
        item (string): the item to be added to the set
        is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
        is_queued (boolean): whether the add operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the add operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when any of setname and item is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.addSetEntry(setname, item, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.addSetEntry(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.addStorageTriggerForWorkflow"><code class="name flex">
<span>def <span class="ident">addStorageTriggerForWorkflow</span></span>(<span>self, workflowName, tableName)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addStorageTriggerForWorkflow(self, workflowName, tableName):
    _nginx = self._nginx
    _useremail = self._useremail
    _usertoken = self._usertoken
    _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

    request = \
    {
        &#34;action&#34;: &#34;addStorageTriggerForWorkflow&#34;,
        &#34;data&#34;: {
            &#34;user&#34;: {&#34;token&#34;: _usertoken},
            &#34;workflowname&#34;: workflowName,
            &#34;tablename&#34;: tableName
        }
    }
    r = requests.post(_url, json=request, verify=False)
    #print(r.text)
    response = json.loads(r.text)
    # {
    #   &#39;status&#39;: &#39;success&#39;, 
    #   &#39;data&#39;: {
    #       &#39;message&#39;: &#39;...&#39;,
    #   }
    # }
    if response[&#34;status&#34;] != &#39;success&#39;:
        print(&#34;Unable to add a storage trigger for workflow &#34; + workflowName + &#34;, Triggerable table &#34; + tableName + &#34;, &#34; + str(response))
        return False
    return True</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.addTriggerableTable"><code class="name flex">
<span>def <span class="ident">addTriggerableTable</span></span>(<span>self, tableName)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addTriggerableTable(self, tableName):
    _nginx = self._nginx
    _useremail = self._useremail
    _usertoken = self._usertoken
    _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

    request = \
    {
        &#34;action&#34;: &#34;addTriggerableTable&#34;,
        &#34;data&#34;: {
            &#34;user&#34;: {&#34;token&#34;: _usertoken},
            &#34;tablename&#34;: tableName
        }
    }
    r = requests.post(_url, json=request, verify=False)
    #print(r.text)
    response = json.loads(r.text)
    # {
    #   &#39;status&#39;: &#39;success&#39;, 
    #   &#39;data&#39;: {
    #       &#39;message&#39;: &#39;...&#39;,
    #   }
    # }
    if response[&#34;status&#34;] != &#39;success&#39;:
        print(&#34;Unable to add a triggerable table. &#34; + str(response))
        return False
    return True</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.add_dynamic_next"><code class="name flex">
<span>def <span class="ident">add_dynamic_next</span></span>(<span>self, next, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Alias for add_workflow_next(self, next, value).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dynamic_next(self, next, value):
    &#39;&#39;&#39;
    Alias for add_workflow_next(self, next, value).
    &#39;&#39;&#39;
    self.add_workflow_next(next, value)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.add_dynamic_workflow"><code class="name flex">
<span>def <span class="ident">add_dynamic_workflow</span></span>(<span>self, dynamic_trigger)</span>
</code></dt>
<dd>
<section class="desc"><p>Add dynamically generated trigger(s) to the workflow.
The dynamically generated trigger can be a single dictionary with 'next' and 'value' fields,
or a list of dictionaries with 'next' and 'value' fields.
In each dictionary, the 'next' field defines the next function that needs to be triggered.
The 'value' field defines the input to the respective next function.
This function will check the validity of the dictionary and raise MicroFunctionsWorkflowException if either 'next' is not a string or 'value' is not a valid python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dynamic_trigger</code></strong> :&ensp;<code>list</code> of <code>dicts</code>, or <code>dict</code></dt>
<dd>each dictionary must be of the form: {'next': <type 'str'>, 'value': <type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>}</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsWorkflowException</code></strong></dt>
<dd>when the input is neither a list of dictionaries or a single dictionary.</dd>
<dt><strong><code>MicroFunctionsWorkflowException</code></strong></dt>
<dd>when in a dictionary, 'next' or 'value' is missing.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dynamic_workflow(self, dynamic_trigger):
    &#39;&#39;&#39;
    Add dynamically generated trigger(s) to the workflow.
    The dynamically generated trigger can be a single dictionary with &#39;next&#39; and &#39;value&#39; fields,
    or a list of dictionaries with &#39;next&#39; and &#39;value&#39; fields.
    In each dictionary, the &#39;next&#39; field defines the next function that needs to be triggered.
    The &#39;value&#39; field defines the input to the respective next function.
    This function will check the validity of the dictionary and raise MicroFunctionsWorkflowException if either &#39;next&#39; is not a string or &#39;value&#39; is not a valid python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

    Args:
        dynamic_trigger (list of dicts, or dict): each dictionary must be of the form: {&#39;next&#39;: &lt;type &#39;str&#39;&gt;, &#39;value&#39;: &lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;}

    Returns:
        None

    Raises:
        MicroFunctionsWorkflowException: when the input is neither a list of dictionaries or a single dictionary.
        MicroFunctionsWorkflowException: when in a dictionary, &#39;next&#39; or &#39;value&#39; is missing.

    &#39;&#39;&#39;
    # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
    # we make the conversion according to the runtime
    dynamic_trigger = self._publication_utils.convert_api_message_to_python_object(dynamic_trigger)

    is_valid = True
    # &#39;dynamic_trigger&#39; can be a single dictionary or a list of dictionaries.
    # each dictionary must be of the form: {&#39;next&#39;: &lt;type &#39;str&#39;&gt;, &#39;value&#39;: &lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;}
    if isinstance(dynamic_trigger, dict):
        if &#39;next&#39; in dynamic_trigger and &#39;value&#39; in dynamic_trigger:
            self.add_workflow_next(dynamic_trigger[&#39;next&#39;], dynamic_trigger[&#39;value&#39;])
        else:
            errmsg = &#34;Malformed dynamic trigger definition; &#39;next&#39; and &#39;value&#39; must be present in the trigger dict().&#34;
            is_valid = False
    elif isinstance(dynamic_trigger, list):
        for trigger in dynamic_trigger:
            if &#39;next&#39; in trigger and &#39;value&#39; in trigger:
                self.add_workflow_next(trigger[&#39;next&#39;], trigger[&#39;value&#39;])
            else:
                errmsg = &#34;Malformed dynamic trigger definition; &#39;next&#39; and &#39;value&#39; must be present in the trigger dict().&#34;
                is_valid = False
                break
    else:
        errmsg = &#34;Malformed dynamic trigger definition; use either a dict() with &#39;next&#39; and &#39;value&#39; fields or a list of dict().&#34;
        is_valid = False

    if not is_valid:
        raise MicroFunctionsWorkflowException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.add_workflow_next"><code class="name flex">
<span>def <span class="ident">add_workflow_next</span></span>(<span>self, next, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Construct a dynamic trigger and add it to the workflow.
The dynamic trigger will define the next function to be executed after this function
and the value that will be passed as input to the next function.
If the 'value' field is not used, the 'next' function will be executed with an empty string as input.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>next</code></strong> :&ensp;<code>string</code></dt>
<dd>the function name to be executed after this function; must be of a string.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>the input value to be passed to the next function; can be any python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsWorkflowException</code></strong></dt>
<dd>when either 'next' is not a string or 'value' is not a valid python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_workflow_next(self, next, value):
    &#39;&#39;&#39;
    Construct a dynamic trigger and add it to the workflow.
    The dynamic trigger will define the next function to be executed after this function
    and the value that will be passed as input to the next function.
    If the &#39;value&#39; field is not used, the &#39;next&#39; function will be executed with an empty string as input.

    Args:
        next (string): the function name to be executed after this function; must be of a string.
        value: the input value to be passed to the next function; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

    Returns:
        None

    Raises:
        MicroFunctionsWorkflowException: when either &#39;next&#39; is not a string or &#39;value&#39; is not a valid python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

    &#39;&#39;&#39;
    # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
    # we make the conversion according to the runtime
    value = self._publication_utils.convert_api_message_to_python_object(value)

    is_valid, is_privileged, errmsg = self._publication_utils.is_valid_trigger_message(next, value, False)

    if is_valid:
        trigger = {}
        trigger[&#34;next&#34;] = next
        trigger[&#34;value&#34;] = value
        trigger[&#34;is_privileged&#34;] = is_privileged
        self._publication_utils.append_trigger(trigger)
    else:
        raise MicroFunctionsWorkflowException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.clearMap"><code class="name flex">
<span>def <span class="ident">clearMap</span></span>(<span>self, mapname, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map to be cleared</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the map should be cleared in the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the clear operation should be reflected on the data layer after the execution finish; default: False
(i.e., the clear operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the mapname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearMap(self, mapname, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map to be cleared
        is_private (boolean): whether the map should be cleared in the private data layer of the workflow; default: False
        is_queued (boolean): whether the clear operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the clear operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the mapname is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(mapname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.clearMap(mapname, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.clearMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.clearSet"><code class="name flex">
<span>def <span class="ident">clearSet</span></span>(<span>self, setname, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>setname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the set to be cleared</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the set should be cleared in the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the clear operation should be reflected on the data layer after the execution finish; default: False
(i.e., the clear operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the setname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearSet(self, setname, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        setname (string): the name of the set to be cleared
        is_private (boolean): whether the set should be cleared in the private data layer of the workflow; default: False
        is_queued (boolean): whether the clear operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the clear operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the setname is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(setname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.clearSet(setname, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.clearSet(setname) accepts a string as &#39;setname&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.containsMapKey"><code class="name flex">
<span>def <span class="ident">containsMapKey</span></span>(<span>self, mapname, key, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>the key of the data item</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the map should be checked in the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code> <code>if</code> <code>key</code> <code>exists</code> <code>in</code> <code>the</code> <code>map</code>; <code>False</code> <code>otherwise</code> (<code>boolean</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when any of mapname and key is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def containsMapKey(self, mapname, key, is_private=False):
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map
        key (string): the key of the data item
        is_private (boolean): whether the map should be checked in the private data layer of the workflow; default: False

    Returns:
        True if key exists in the map; False otherwise (boolean)

    Raises:
        MicroFunctionsDataLayerException: when any of mapname and key is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool):
        return self._data_layer_operator.containsMapKey(mapname, key, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.containsMapKey(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.containsSetItem"><code class="name flex">
<span>def <span class="ident">containsSetItem</span></span>(<span>self, setname, item, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>setname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the set</dd>
<dt><strong><code>item</code></strong> :&ensp;<code>string</code></dt>
<dd>the item to be checked in the set</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be checked in the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code> <code>if</code> <code>item</code> <code>exists</code> <code>in</code> <code>the</code> <code>set</code>; <code>False</code> <code>otherwise</code> (<code>boolean</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when any of setname and item is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def containsSetItem(self, setname, item, is_private=False):
    &#39;&#39;&#39;
    Args:
        setname (string): the name of the set
        item (string): the item to be checked in the set
        is_private (boolean): whether the item should be checked in the private data layer of the workflow; default: False

    Returns:
        True if item exists in the set; False otherwise (boolean)

    Raises:
        MicroFunctionsDataLayerException: when any of setname and item is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool):
        return self._data_layer_operator.containsSetItem(setname, item, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.containsSetItem(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.createCounter"><code class="name flex">
<span>def <span class="ident">createCounter</span></span>(<span>self, countername, count, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>countername</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the counter to be created</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>the initial value of the counter</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the counter should be created in the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the create operation should be reflected on the data layer after the execution finish; default: False
(i.e., the create operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the countername is not a string and/or the initial count is not an integer.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createCounter(self, countername, count, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        countername (string): the name of the counter to be created
        count (int): the initial value of the counter
        is_private (boolean): whether the counter should be created in the private data layer of the workflow; default: False
        is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the create operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the countername is not a string and/or the initial count is not an integer.

    &#39;&#39;&#39;
    if py3utils.is_string(countername) and isinstance(count, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.createCounter(countername, count, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.createCounter(countername, count) accepts a string as &#39;countername&#39; and an integer as &#39;count&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.createMap"><code class="name flex">
<span>def <span class="ident">createMap</span></span>(<span>self, mapname, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map to be created</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the map should be created in the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the create operation should be reflected on the data layer after the execution finish; default: False
(i.e., the create operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the mapname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createMap(self, mapname, is_private=False, is_queued=False):
    # _XXX_: the backend at the data layer does not create
    # sets and maps (i.e., createSet, createMap) until an entry is made
    # the addition of the entries will succeed without requiring the
    # corresponding set/map to have been created.
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map to be created
        is_private (boolean): whether the map should be created in the private data layer of the workflow; default: False
        is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the create operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the mapname is not a string.

    &#39;&#39;&#39;
    self._logger.warning(&#34;MicroFunctionsAPI.createMap() does not have an effect; it will be removed in the future.&#34;)
    self._logger.warning(&#34;(Entries can still be added without calling createMap() beforehand.)&#34;)
    return</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.createSet"><code class="name flex">
<span>def <span class="ident">createSet</span></span>(<span>self, setname, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>setname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the set to be created</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the set should be created in the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the create operation should be reflected on the data layer after the execution finish; default: False
(i.e., the create operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the setname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createSet(self, setname, is_private=False, is_queued=False):
    # _XXX_: the backend at the data layer does not create
    # sets and maps (i.e., createSet, createMap) until an entry is made
    # the addition of the entries will succeed without requiring the
    # corresponding set/map to have been created.
    &#39;&#39;&#39;
    Args:
        setname (string): the name of the set to be created
        is_private (boolean): whether the set should be created in the private data layer of the workflow; default: False
        is_queued (boolean): whether the create operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the create operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the setname is not a string.

    &#39;&#39;&#39;
    self._logger.warning(&#34;MicroFunctionsAPI.createSet() does not have an effect; it will be removed in the future.&#34;)
    self._logger.warning(&#34;(Items can still be added without calling createSet() beforehand.)&#34;)
    return</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.decrementCounter"><code class="name flex">
<span>def <span class="ident">decrementCounter</span></span>(<span>self, countername, decrement, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>countername</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the counter to be decremented</dd>
<dt><strong><code>decrement</code></strong> :&ensp;<code>int</code></dt>
<dd>the value to be subtracted from the counter</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the counter should be decremented in the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the decrement operation should be reflected on the data layer after the execution finish; default: False
(i.e., the decrement operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the countername is not a string and/or the decrement is not an integer.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrementCounter(self, countername, decrement, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        countername (string): the name of the counter to be decremented
        decrement (int): the value to be subtracted from the counter
        is_private (boolean): whether the counter should be decremented in the private data layer of the workflow; default: False
        is_queued (boolean): whether the decrement operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the decrement operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the countername is not a string and/or the decrement is not an integer.

    &#39;&#39;&#39;
    if py3utils.is_string(countername) and isinstance(decrement, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.decrementCounter(countername, decrement, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.decrementCounter(countername, increment) accepts a string as &#39;countername&#39; and an integer as &#39;decrement&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, key, is_private=False, is_queued=False, tableName=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Alias for remove(key, is_private, is_queued, tableName).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, key, is_private=False, is_queued=False, tableName=None):
    &#39;&#39;&#39;
    Alias for remove(key, is_private, is_queued, tableName).
    &#39;&#39;&#39;
    self.remove(key, is_private, is_queued, tableName)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.deleteCounter"><code class="name flex">
<span>def <span class="ident">deleteCounter</span></span>(<span>self, countername, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>countername</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the counter to be deleted</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the counter should be deleted in the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the delete operation should be reflected on the data layer after the execution finish; default: False
(i.e., the delete operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the countername is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteCounter(self, countername, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        countername (string): the name of the counter to be deleted
        is_private (boolean): whether the counter should be deleted in the private data layer of the workflow; default: False
        is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the delete operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the countername is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(countername) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.deleteCounter(countername, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.deleteCounter(countername) accepts a string as &#39;countername&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.deleteMap"><code class="name flex">
<span>def <span class="ident">deleteMap</span></span>(<span>self, mapname, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map to be deleted</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the map should be deleted from the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the delete operation should be reflected on the data layer after the execution finish; default: False
(i.e., the delete operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the mapname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteMap(self, mapname, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map to be deleted
        is_private (boolean): whether the map should be deleted from the private data layer of the workflow; default: False
        is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the delete operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the mapname is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(mapname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.deleteMap(mapname, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.deleteMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.deleteMapEntry"><code class="name flex">
<span>def <span class="ident">deleteMapEntry</span></span>(<span>self, mapname, key, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>the key of the data item</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be deleted from the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the delete operation should be reflected on the data layer after the execution finish; default: False
(i.e., the delete operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when any of mapname and key is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteMapEntry(self, mapname, key, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map
        key (string): the key of the data item
        is_private (boolean): whether the item should be deleted from the private data layer of the workflow; default: False
        is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the delete operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when any of mapname and key is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.deleteMapEntry(mapname, key, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.deleteMapEntry(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.deleteSet"><code class="name flex">
<span>def <span class="ident">deleteSet</span></span>(<span>self, setname, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>setname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the set to be deleted</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the set should be deleted from the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the delete operation should be reflected on the data layer after the execution finish; default: False
(i.e., the delete operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the setname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteSet(self, setname, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        setname (string): the name of the set to be deleted
        is_private (boolean): whether the set should be deleted from the private data layer of the workflow; default: False
        is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the delete operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the setname is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(setname) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.deleteSet(setname, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.deleteSet(setname) accepts a string as &#39;setname&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.deleteStorageTriggerForWorkflow"><code class="name flex">
<span>def <span class="ident">deleteStorageTriggerForWorkflow</span></span>(<span>self, workflowName, tableName)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteStorageTriggerForWorkflow(self, workflowName, tableName):
    _nginx = self._nginx
    _useremail = self._useremail
    _usertoken = self._usertoken
    _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

    request = \
    {
        &#34;action&#34;: &#34;deleteStorageTriggerForWorkflow&#34;,
        &#34;data&#34;: {
            &#34;user&#34;: {&#34;token&#34;: _usertoken},
            &#34;workflowname&#34;: workflowName,
            &#34;tablename&#34;: tableName
        }
    }
    r = requests.post(_url, json=request, verify=False)
    #print(r.text)
    response = json.loads(r.text)
    # {
    #   &#39;status&#39;: &#39;success&#39;, 
    #   &#39;data&#39;: {
    #       &#39;message&#39;: &#39;...&#39;,
    #   }
    # }
    if response[&#34;status&#34;] != &#39;success&#39;:
        print(&#34;Unable to delete a storage trigger for workflow &#34; + workflowName + &#34;, Triggerable table &#34; + tableName + &#34;, &#34; + str(response))
        return False
    return True</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.deleteTriggerableTable"><code class="name flex">
<span>def <span class="ident">deleteTriggerableTable</span></span>(<span>self, tableName)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteTriggerableTable(self, tableName):
    _nginx = self._nginx
    _useremail = self._useremail
    _usertoken = self._usertoken
    _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

    request = \
    {
        &#34;action&#34;: &#34;deleteTriggerableTable&#34;,
        &#34;data&#34;: {
            &#34;user&#34;: {&#34;token&#34;: _usertoken},
            &#34;tablename&#34;: tableName
        }
    }
    r = requests.post(_url, json=request, verify=False)
    #print(r.text)
    response = json.loads(r.text)
    # {
    #   &#39;status&#39;: &#39;success&#39;, 
    #   &#39;data&#39;: {
    #       &#39;message&#39;: &#39;...&#39;,
    #   }
    # }
    if response[&#34;status&#34;] != &#39;success&#39;:
        print(&#34;Unable to delete a triggerable table. &#34; + str(response))
        return False
    return True</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key, is_private=False, tableName=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Access to data layer to load the value of a given key.
The key is first checked in the transient deleted items.
If it is not deleted, the key is then checked in the transient data table.
If it is not there, it is retrieved from the global data layer.
As a result, the value returned is consistent with
what this function instance does with the data item.
If the data item is not present in either the transient data table
nor in the global data layer, an empty string (i.e., "") will be
returned.
If the function used put() and delete() operations with is_queued=False (default),
then the checks of the transient table will result in empty values,
so that the item will be retrieved from the global data layer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>the key of the data item</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be read from the private data layer of the workflow; default: False</dd>
<dt><strong><code>tableName</code></strong> :&ensp;<code>string</code></dt>
<dd>name of the table where to get the key from. By default, it will be fetched from the default table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>string</code></dt>
<dd>the value of the data item; empty string if the data item is not present.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the key is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key, is_private=False, tableName=None):
    &#39;&#39;&#39;
    Access to data layer to load the value of a given key.
    The key is first checked in the transient deleted items.
    If it is not deleted, the key is then checked in the transient data table.
    If it is not there, it is retrieved from the global data layer.
    As a result, the value returned is consistent with
    what this function instance does with the data item.
    If the data item is not present in either the transient data table
    nor in the global data layer, an empty string (i.e., &#34;&#34;) will be
    returned.
    If the function used put() and delete() operations with is_queued=False (default),
    then the checks of the transient table will result in empty values,
    so that the item will be retrieved from the global data layer.

    Args:
        key (string): the key of the data item
        is_private (boolean): whether the item should be read from the private data layer of the workflow; default: False
        tableName (string): name of the table where to get the key from. By default, it will be fetched from the default table.

    Returns:
        value (string): the value of the data item; empty string if the data item is not present.

    Raises:
        MicroFunctionsDataLayerException: when the key is not a string.
    &#39;&#39;&#39;
    # check first transient_output
    # if not there, return the actual (global) data layer data item
    # if not there either, return empty string (as defined in the DataLayerClient)
    if py3utils.is_string(key) and isinstance(is_private, bool):
        return self._data_layer_operator.get(key, is_private, table=tableName)
    else:
        errmsg = &#34;MicroFunctionsAPI.get(key) accepts a string as &#39;key&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.getCounterNames"><code class="name flex">
<span>def <span class="ident">getCounterNames</span></span>(<span>self, start_index=0, end_index=2147483647, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_index</code></strong> :&ensp;<code>int</code></dt>
<dd>the starting index of the counter names to be retrieved; default: 0</dd>
<dt><strong><code>end_index</code></strong> :&ensp;<code>int</code></dt>
<dd>the end index of the counter names to be retrieved; default: 2147483647</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the counter names should be retrieved from the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code> of <code>counter</code> <code>names</code> (<code>list</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when start_index &lt; 0 and/or end_index &gt; 2147483647.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCounterNames(self, start_index=0, end_index=2147483647, is_private=False):
    &#39;&#39;&#39;
    Args:
        start_index (int): the starting index of the counter names to be retrieved; default: 0
        end_index (int): the end index of the counter names to be retrieved; default: 2147483647
        is_private (boolean): whether the counter names should be retrieved from the private data layer of the workflow; default: False

    Returns:
        List of counter names (list)

    Raises:
        MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

    &#39;&#39;&#39;
    if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
        return self._data_layer_operator.getCounterNames(start_index, end_index, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.getCounterNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.getCounterValue"><code class="name flex">
<span>def <span class="ident">getCounterValue</span></span>(<span>self, countername, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>countername</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the counter whose value is to be retrieved</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the counter should be retrieved from the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The current value of the counter (int), or None if the counter does not exist.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the countername is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCounterValue(self, countername, is_private=False):
    &#39;&#39;&#39;
    Args:
        countername (string): the name of the counter whose value is to be retrieved
        is_private (boolean): whether the counter should be retrieved from the private data layer of the workflow; default: False

    Returns:
        The current value of the counter (int), or None if the counter does not exist.

    Raises:
        MicroFunctionsDataLayerException: when the countername is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(countername) and isinstance(is_private, bool):
        return self._data_layer_operator.getCounterValue(countername, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.getCounterValue(countername) accepts a string as &#39;countername&#39;.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.getMapEntry"><code class="name flex">
<span>def <span class="ident">getMapEntry</span></span>(<span>self, mapname, key, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>the key of the data item</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be retrieved from the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The value associated with the key in the map (string), or empty string "" if the key does not exist.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when any of mapname and key is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMapEntry(self, mapname, key, is_private=False):
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map
        key (string): the key of the data item
        is_private (boolean): whether the item should be retrieved from the private data layer of the workflow; default: False

    Returns:
        The value associated with the key in the map (string), or empty string &#34;&#34; if the key does not exist.

    Raises:
        MicroFunctionsDataLayerException: when any of mapname and key is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(mapname) and py3utils.is_string(key) and isinstance(is_private, bool):
        return self._data_layer_operator.getMapEntry(mapname, key, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.getMapEntry(mapname, key) accepts a string as &#39;mapname&#39; and &#39;key&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.getMapKeys"><code class="name flex">
<span>def <span class="ident">getMapKeys</span></span>(<span>self, mapname, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map whose keys are to be retrieved</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the map should be retrieved from the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Set</code> of <code>map</code> <code>keys</code> (<code>set</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the mapname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMapKeys(self, mapname, is_private=False):
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map whose keys are to be retrieved
        is_private (boolean): whether the map should be retrieved from the private data layer of the workflow; default: False

    Returns:
        Set of map keys (set)

    Raises:
        MicroFunctionsDataLayerException: when the mapname is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(mapname) and isinstance(is_private, bool):
        return self._data_layer_operator.getMapKeys(mapname, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.getMapKeys(mapname) accepts a string as &#39;mapname&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.getMapNames"><code class="name flex">
<span>def <span class="ident">getMapNames</span></span>(<span>self, start_index=0, end_index=2147483647, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_index</code></strong> :&ensp;<code>int</code></dt>
<dd>the starting index of the map names to be retrieved; default: 0</dd>
<dt><strong><code>end_index</code></strong> :&ensp;<code>int</code></dt>
<dd>the end index of the map names to be retrieved; default: 2147483647</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the map names should be retrieved from the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code> of <code>map</code> <code>names</code> (<code>list</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when start_index &lt; 0 and/or end_index &gt; 2147483647.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMapNames(self, start_index=0, end_index=2147483647, is_private=False):
    &#39;&#39;&#39;
    Args:
        start_index (int): the starting index of the map names to be retrieved; default: 0
        end_index (int): the end index of the map names to be retrieved; default: 2147483647
        is_private (boolean): whether the map names should be retrieved from the private data layer of the workflow; default: False

    Returns:
        List of map names (list)

    Raises:
        MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

    &#39;&#39;&#39;
    if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
        return self._data_layer_operator.getMapNames(start_index, end_index, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.getMapNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.getSetNames"><code class="name flex">
<span>def <span class="ident">getSetNames</span></span>(<span>self, start_index=0, end_index=2147483647, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_index</code></strong> :&ensp;<code>int</code></dt>
<dd>the starting index of the set names to be retrieved; default: 0</dd>
<dt><strong><code>end_index</code></strong> :&ensp;<code>int</code></dt>
<dd>the end index of the set names to be retrieved; default: 2147483647</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the set names should be retrieved from the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code> of <code>set</code> <code>names</code> (<code>list</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when start_index &lt; 0 and/or end_index &gt; 2147483647.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSetNames(self, start_index=0, end_index=2147483647, is_private=False):
    &#39;&#39;&#39;
    Args:
        start_index (int): the starting index of the set names to be retrieved; default: 0
        end_index (int): the end index of the set names to be retrieved; default: 2147483647
        is_private (boolean): whether the set names should be retrieved from the private data layer of the workflow; default: False

    Returns:
        List of set names (list)

    Raises:
        MicroFunctionsDataLayerException: when start_index &lt; 0 and/or end_index &gt; 2147483647.

    &#39;&#39;&#39;
    if start_index &gt;= 0 and end_index &lt;= 2147483647 and isinstance(is_private, bool):
        return self._data_layer_operator.getSetNames(start_index, end_index, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.getSetNames(start_index, end_index) accepts indices between 0 and 2147483647 (defaults).&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.getTriggerableTables"><code class="name flex">
<span>def <span class="ident">getTriggerableTables</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTriggerableTables(self):
    _nginx = self._nginx
    _useremail = self._useremail
    _usertoken = self._usertoken
    _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

    request = \
    {
        &#34;action&#34;: &#34;getTriggerableTables&#34;,
        &#34;data&#34;: {
            &#34;user&#34;: {&#34;token&#34;: _usertoken}
        }
    }
    r = requests.post(_url, json=request, verify=False)
    #print(r.text)
    response = json.loads(r.text)
    # {
    #   &#39;status&#39;: &#39;success&#39;, 
    #   &#39;data&#39;: {
    #       &#39;message&#39;: &#39;...&#39;,
    #       &#39;tables&#39;: {
    #           &#39;&lt;table-name-1&gt;&#39;: [list of workflow names associated with &lt;table-name-1&gt;],
    #           &#39;&lt;table-name-2&gt;&#39;: [list of workflow names associated with &lt;table-name-2&gt;],
    #           ...
    #       }
    #   }
    # }
    if response[&#34;status&#34;] != &#39;success&#39;:
        print(&#34;Unable to fetch details for triggerable tables, error: &#34; + str(response))
    return response</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.getWorkflowDetails"><code class="name flex">
<span>def <span class="ident">getWorkflowDetails</span></span>(<span>self, workflowName)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWorkflowDetails(self, workflowName):
    _nginx = self._nginx
    _useremail = self._useremail
    _usertoken = self._usertoken
    _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

    request = \
    {
        &#34;action&#34;: &#34;getWorkflowDetails&#34;,
        &#34;data&#34;: {
            &#34;user&#34;: {&#34;token&#34;: _usertoken},
            &#34;workflowname&#34;: workflowName
        }
    }
    r = requests.post(_url, json=request, verify=False)
    #print(r.text)
    response = json.loads(r.text)
    # {
    #   &#39;status&#39;: &#39;success&#39;, 
    #   &#39;data&#39;: {
    #       &#39;email&#39;: &#39;...&#39;,
    #       &#39;name&#39;: &#39;...&#39;,
    #       &#39;id&#39;: &#39;...&#39;,
    #       &#39;status&#39;: &#39;...&#39;,
    #       &#39;endpoint&#39;: &#39;...&#39;,
    #       &#39;entry_topic&#39;: &#39;...&#39;,
    #       &#39;entry_grain&#39;: &#39;...&#39;,
    #       &#39;modified&#39;: &#39;...&#39;,
    #       &#39;associatedTriggerableTables&#39;: {
    #           &#39;&lt;table-name-1&gt;&#39;: &#39;&#39;, 
    #           &#39;&lt;table-name-2&gt;&#39;: &#39;&#39;, 
    #           ...
    #       }
    #   }
    # }
    if response[&#34;status&#34;] != &#39;success&#39;:
        print(&#34;Unable to fetch details for workflow: &#34; + workflowName + &#34;, error: &#34; + str(response))
    return response</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_alias_summary"><code class="name flex">
<span>def <span class="ident">get_alias_summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve a summary of the aliases of the current session and its session function instances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dictionary with two keys &ndash; 'session' and 'session_functions', each referring to another dictionary.
'session' dictionary will have an item with the session id as the key and the session alias as the value.
'session_functions' dictionary will have one or more entries, where each key will be the id of a session function instance
and the corresponding value will be the alias assigned to that session function instance.
If any alias is not set, then the values will be None.</p>
<h2 id="warns">Warns</h2>
<p>When the calling function is not part of a workflow with at least one session function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alias_summary(self):
    &#39;&#39;&#39;
    Retrieve a summary of the aliases of the current session and its session function instances.

    Args:
        None

    Returns:
        Dictionary with two keys -- &#39;session&#39; and &#39;session_functions&#39;, each referring to another dictionary.
        &#39;session&#39; dictionary will have an item with the session id as the key and the session alias as the value.
        &#39;session_functions&#39; dictionary will have one or more entries, where each key will be the id of a session function instance
        and the corresponding value will be the alias assigned to that session function instance.
        If any alias is not set, then the values will be None.

    Warns:
        When the calling function is not part of a workflow with at least one session function.

    &#39;&#39;&#39;
    alias_summary = {}
    if self._is_session_workflow:
        alias_summary = self._session_utils.get_alias_summary()
    else:
        self._logger.warning(&#34;Cannot get alias summary for session in a workflow with no session functions.&#34;)
    return alias_summary</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_all_session_function_aliases"><code class="name flex">
<span>def <span class="ident">get_all_session_function_aliases</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve the session function instance and alias mapping for all the session function instances in this session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary with session function instance id as the key and the alias as the value involving all session function instances in this session.</p>
<h2 id="warns">Warns</h2>
<p>When the calling function is not part of a workflow with at least one session function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_session_function_aliases(self):
    &#39;&#39;&#39;
    Retrieve the session function instance and alias mapping for all the session function instances in this session.

    Args:
        None

    Returns:
        A dictionary with session function instance id as the key and the alias as the value involving all session function instances in this session.

    Warns:
        When the calling function is not part of a workflow with at least one session function.

    &#39;&#39;&#39;
    aliases = {}
    if self._is_session_workflow:
        aliases = self._session_utils.get_all_session_function_aliases()
    else:
        self._logger.warning(&#34;Cannot get session function aliases in a workflow with no session functions.&#34;)
    return aliases</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_all_session_function_ids"><code class="name flex">
<span>def <span class="ident">get_all_session_function_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve a list of all ids of the session function instances in this session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of ids of all the session function instances in this session.</p>
<h2 id="warns">Warns</h2>
<p>When the calling function is not part of a workflow with at least one session function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_session_function_ids(self):
    &#39;&#39;&#39;
    Retrieve a list of all ids of the session function instances in this session.

    Args:
        None

    Returns:
        List of ids of all the session function instances in this session.

    Warns:
        When the calling function is not part of a workflow with at least one session function.

    &#39;&#39;&#39;
    rgidlist = []
    if self._is_session_workflow:
        rgidlist = self._session_utils.get_all_session_function_ids()
    else:
        self._logger.warning(&#34;Cannot get session function ids in a workflow with no session functions.&#34;)
    return rgidlist</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_data_to_be_deleted"><code class="name flex">
<span>def <span class="ident">get_data_to_be_deleted</span></span>(<span>self, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the list of deleted data items, so that they can be committed to the data layer
when the function instance finishes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_to_be_deleted(self, is_private=False):
    &#39;&#39;&#39;
    Return the list of deleted data items, so that they can be committed to the data layer
    when the function instance finishes.
    &#39;&#39;&#39;
    return self._data_layer_operator.get_data_to_be_deleted(is_private)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_dynamic_workflow"><code class="name flex">
<span>def <span class="ident">get_dynamic_workflow</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the dynamically generated workflow information,
so that this function instance can trigger other functions when it finishes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dynamic_workflow(self):
    &#39;&#39;&#39;
    Return the dynamically generated workflow information,
    so that this function instance can trigger other functions when it finishes.
    &#39;&#39;&#39;
    return self._publication_utils.get_dynamic_workflow()</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_event_key"><code class="name flex">
<span>def <span class="ident">get_event_key</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the function instance id (i.e., the key of the trigger event).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_event_key(self):
    &#39;&#39;&#39;
    Return the function instance id (i.e., the key of the trigger event).
    &#39;&#39;&#39;
    return self._instanceid</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_instance_id"><code class="name flex">
<span>def <span class="ident">get_instance_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the function instance id (i.e., the key of the trigger event).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_instance_id(self):
    &#39;&#39;&#39;
    Return the function instance id (i.e., the key of the trigger event).
    &#39;&#39;&#39;
    return self._instanceid</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_privileged_data_layer_client"><code class="name flex">
<span>def <span class="ident">get_privileged_data_layer_client</span></span>(<span>self, suid=None, keyspace=None, tablename=None, maptablename=None, settablename=None, countertablename=None, init_tables=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_privileged_data_layer_client(self, suid=None, keyspace=None, tablename=None, maptablename=None, settablename=None, countertablename=None, init_tables=False):
    if self._is_privileged:
        if suid is not None:
            return DataLayerClient(locality=1, suid=suid, connect=self._datalayer, init_tables=init_tables)
        elif keyspace is not None and tablename is not None:
            dlc = DataLayerClient(locality=1, for_mfn=True, connect=self._datalayer)
            dlc.keyspace = keyspace
            dlc.tablename = tablename
            if maptablename is not None:
                dlc.maptablename = maptablename
            if settablename is not None:
                dlc.settablename = settablename
            if countertablename is not None:
                dlc.countertablename = countertablename
            return dlc
    return None</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_remaining_time_in_millis"><code class="name flex">
<span>def <span class="ident">get_remaining_time_in_millis</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the remaining time this function instance is allowed to continue running.
The time is returned in milliseconds.
This function exists for AWS Lambda compatibility.
As of 10.04.2018, the maximum time a function instance can execute is not limited.
This will change in the future.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_remaining_time_in_millis(self):
    &#39;&#39;&#39;
    Return the remaining time this function instance is allowed to continue running.
    The time is returned in milliseconds.
    This function exists for AWS Lambda compatibility.
    As of 10.04.2018, the maximum time a function instance can execute is not limited.
    This will change in the future.
    &#39;&#39;&#39;
    # 5 minutes always
    return 300000</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_session_alias"><code class="name flex">
<span>def <span class="ident">get_session_alias</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve the existing alias of the current session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The existing session alias (string) or None if no alias is set.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session_alias(self):
    &#39;&#39;&#39;
    Retrieve the existing alias of the current session.

    Args:
        None

    Returns:
        The existing session alias (string) or None if no alias is set.

    &#39;&#39;&#39;
    if self._is_session_workflow:
        return self._session_utils.get_session_alias()
    else:
        self._logger.warning(&#34;Cannot get a session alias in a workflow with no session functions.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_alias"><code class="name flex">
<span>def <span class="ident">get_session_function_alias</span></span>(<span>self, session_function_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve the current alias of the session function instance in this session.
If the session function id is not set, the current function instance's alias will be retrieved.
If it is set, the alias of the session function instance corresponding to the id will be retrieved.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>session_function_id</code></strong> :&ensp;<code>string</code></dt>
<dd>the id of the session function instance whose alias should be retrieved; default: None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The existing alias of the session function instance (string) or None if no alias is set.</p>
<h2 id="warns">Warns</h2>
<p>When calling function is not a session function if session function id is None.
When no session function instance exists with the given session function id.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session_function_alias(self, session_function_id=None):
    &#39;&#39;&#39;
    Retrieve the current alias of the session function instance in this session.
    If the session function id is not set, the current function instance&#39;s alias will be retrieved.
    If it is set, the alias of the session function instance corresponding to the id will be retrieved.

    Args:
        session_function_id (string): the id of the session function instance whose alias should be retrieved; default: None.

    Returns:
        The existing alias of the session function instance (string) or None if no alias is set.

    Warns:
        When calling function is not a session function if session function id is None.
        When no session function instance exists with the given session function id.

    &#39;&#39;&#39;
    # handle another session function&#39;s alias
    if session_function_id is not None:
        return self._session_utils.get_session_function_alias(session_function_id)
    elif self._is_session_function:
        return self._session_utils.get_session_function_alias()
    else:
        self._logger.warning(&#34;Cannot get a session function alias in a non-session function.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_id"><code class="name flex">
<span>def <span class="ident">get_session_function_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve the current session function instance's id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The id of the current session function instance.</p>
<h2 id="warns">Warns</h2>
<p>When the calling function is not a session function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session_function_id(self):
    &#39;&#39;&#39;
    Retrieve the current session function instance&#39;s id.

    Args:
        None

    Returns:
        The id of the current session function instance.

    Warns:
        When the calling function is not a session function.

    &#39;&#39;&#39;
    if self._is_session_function:
        return self._session_utils.get_session_function_id()
    else:
        self._logger.warning(&#34;Cannot get session function id in a non-session function.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_id_with_alias"><code class="name flex">
<span>def <span class="ident">get_session_function_id_with_alias</span></span>(<span>self, alias=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve the id of a session function instance using an alias.
When alias is not set, the id of the current session function instance will be returned.
When it is not set, the id of the session function instance with that alias will be returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alias</code></strong> :&ensp;<code>string</code></dt>
<dd>The alias that needs to be used to retrieve the id of the session function instance; default: None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The id of the current session function instance when alias is not set, or the ide of the session function instance with the given alias.</p>
<h2 id="warns">Warns</h2>
<p>When the calling function is not a session function if the alias is not given.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session_function_id_with_alias(self, alias=None):
    &#39;&#39;&#39;
    Retrieve the id of a session function instance using an alias.
    When alias is not set, the id of the current session function instance will be returned.
    When it is not set, the id of the session function instance with that alias will be returned.

    Args:
        alias (string): The alias that needs to be used to retrieve the id of the session function instance; default: None

    Returns:
        The id of the current session function instance when alias is not set, or the ide of the session function instance with the given alias.

    Warns:
        When the calling function is not a session function if the alias is not given.

    &#39;&#39;&#39;
    # handle another session function&#39;s alias
    if alias is not None:
        return self._session_utils.get_session_function_id_with_alias(alias)
    elif self._is_session_function:
        return self._session_utils.get_session_function_id_with_alias()
    else:
        self._logger.warning(&#34;Cannot get session function id in a non-session function.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_session_id"><code class="name flex">
<span>def <span class="ident">get_session_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve the current session's id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The session id of the current session.</p>
<h2 id="warns">Warns</h2>
<p>When the calling function is not part of a workflow with at least one session function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session_id(self):
    &#39;&#39;&#39;
    Retrieve the current session&#39;s id.

    Args:
        None

    Returns:
        The session id of the current session.

    Warns:
        When the calling function is not part of a workflow with at least one session function.

    &#39;&#39;&#39;
    if self._is_session_workflow:
        return self._session_utils.get_session_id()
    else:
        self._logger.warning(&#34;Cannot get a session id in a workflow with no session functions.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_session_update_messages"><code class="name flex">
<span>def <span class="ident">get_session_update_messages</span></span>(<span>self, count=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve the list of update messages sent to a session function instance.
The list contains messages that were sent and delivered since the last time the session function instance has retrieved it.
These messages are retrieved via a local queue. There can be more than one message.
The optional count argument specifies how many messages should be retrieved.
If there are fewer messages than the requested count, all messages will be retrieved and returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of messages to retrieve; default: 1</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of messages that were sent to the session function instance.</p>
<h2 id="warns">Warns</h2>
<p>When the calling function is not a session function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session_update_messages(self, count=1):
    &#39;&#39;&#39;
    Retrieve the list of update messages sent to a session function instance.
    The list contains messages that were sent and delivered since the last time the session function instance has retrieved it.
    These messages are retrieved via a local queue. There can be more than one message.
    The optional count argument specifies how many messages should be retrieved.
    If there are fewer messages than the requested count, all messages will be retrieved and returned.

    Args:
        count (int): the number of messages to retrieve; default: 1

    Returns:
        List of messages that were sent to the session function instance.

    Warns:
        When the calling function is not a session function.

    &#39;&#39;&#39;
    messages = []
    if self._is_session_function:
        #self._logger.info(&#34;[MicroFunctionsAPI] getting session update messages...&#34;)
        messages = self._session_utils.get_session_update_messages_with_local_queue(count)
    else:
        self._logger.warning(&#34;Cannot get session update messages in a non-session function: &#34; + self._function_state_name)

    return messages</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.get_transient_data_output"><code class="name flex">
<span>def <span class="ident">get_transient_data_output</span></span>(<span>self, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the transient data, so that it can be committed to the data layer
when the function instance finishes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transient_data_output(self, is_private=False):
    &#39;&#39;&#39;
    Return the transient data, so that it can be committed to the data layer
    when the function instance finishes.
    &#39;&#39;&#39;
    return self._data_layer_operator.get_transient_data_output(is_private)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.incrementCounter"><code class="name flex">
<span>def <span class="ident">incrementCounter</span></span>(<span>self, countername, increment, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>countername</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the counter to be incremented</dd>
<dt><strong><code>increment</code></strong> :&ensp;<code>int</code></dt>
<dd>the value to be added to the counter</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the counter should be incremented in the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the increment operation should be reflected on the data layer after the execution finish; default: False
(i.e., the increment operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the countername is not a string and/or the increment is not an integer.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incrementCounter(self, countername, increment, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        countername (string): the name of the counter to be incremented
        increment (int): the value to be added to the counter
        is_private (boolean): whether the counter should be incremented in the private data layer of the workflow; default: False
        is_queued (boolean): whether the increment operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the increment operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the countername is not a string and/or the increment is not an integer.

    &#39;&#39;&#39;
    if py3utils.is_string(countername) and isinstance(increment, int) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.incrementCounter(countername, increment, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.incrementCounter(countername, increment) accepts a string as &#39;countername&#39; and an integer as &#39;increment&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.invokeManagementAction"><code class="name flex">
<span>def <span class="ident">invokeManagementAction</span></span>(<span>self, request)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invokeManagementAction(self, request):
    _nginx = self._nginx
    _useremail = self._useremail
    _usertoken = self._usertoken
    _url = &#34;http://&#34; + _nginx + &#34;/workflow/sandservice/management/ManagementServiceEntry&#34;

    # request = \
    # {
    #     &#34;action&#34;: &#34;getWorkflowDetails&#34;,
    #     &#34;data&#34;: {
    #         &#34;user&#34;: {&#34;token&#34;: &#34;&#34;},
    #         &#34;&lt;other-stuff&gt;&#34;:
    #     }
    # }


    if &#34;action&#34; not in request or &#34;data&#34; not in request or &#34;user&#34; not in request[&#34;data&#34;] or &#34;token&#34; not in request[&#34;data&#34;][&#34;user&#34;]:
        return {&#34;status&#34;: &#34;failure&#34;, &#34;data&#34;: {&#34;message&#34;: &#34;Malformed request&#34;}}

    request[&#34;data&#34;][&#34;user&#34;][&#34;token&#34;] = _usertoken
    r = requests.post(_url, json=request, verify=False)
    #print(r.text)
    response = json.loads(r.text)
    # {
    #   &#39;status&#39;: &#39;success&#39;, 
    #   &#39;data&#39;: {
    #       &#39;message&#39;: &#39;...&#39;,
    #   }
    # }
    if response[&#34;status&#34;] != &#39;success&#39;:
        print(&#34;Unable to invoke action: &#34; + request[&#34;action&#34;] + &#34;, error: &#34; + str(response))
    return response</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.is_still_running"><code class="name flex">
<span>def <span class="ident">is_still_running</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieve the status of this session function instance.
The status of the session function instance could have been changed via a special message
delivered to the session function instance and handled by the platform.
A session function should call this method to handle such cases.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the session function instance has not received a special message to stop, or False otherwise.</p>
<h2 id="warns">Warns</h2>
<p>When the calling function is not a session function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_still_running(self):
    &#39;&#39;&#39;
    Retrieve the status of this session function instance.
    The status of the session function instance could have been changed via a special message
    delivered to the session function instance and handled by the platform.
    A session function should call this method to handle such cases.

    Args:
        None

    Returns:
        True if the session function instance has not received a special message to stop, or False otherwise.

    Warns:
        When the calling function is not a session function.

    &#39;&#39;&#39;
    if self._is_session_function:
        return self._session_utils.is_session_function_running()
    else:
        self._logger.warning(&#34;Cannot get status of running in a non-session function.&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, text, level='INFO')</span>
</code></dt>
<dd>
<section class="desc"><p>Log text. Uses the instance id to indicate which function instance logged the text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code></dt>
<dd>text to be logged.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>string</code></dt>
<dd>log level to be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsUserLogException</code></strong></dt>
<dd>when there are any errors in the logging function.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, text, level=&#34;INFO&#34;):
    &#39;&#39;&#39;
    Log text. Uses the instance id to indicate which function instance logged the text.

    Args:
        text (string): text to be logged.
        level (string): log level to be used.
    Returns:
        None.

    Raises:
        MicroFunctionsUserLogException: when there are any errors in the logging function.
    &#39;&#39;&#39;

    if level == &#34;INFO&#34;:
        self._logger.info(text)
    elif level == &#34;WARNING&#34;:
        self._logger.warning(text)
    elif level == &#34;DEBUG&#34;:
        self._logger.debug(text)
    elif level == &#34;ERROR&#34;:
        self._logger.error(text)
    else:
        raise MicroFunctionsUserLogException(&#34;User logging exception; unsupported log level: &#34; + str(level))</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self, num)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(self, num):
    self._logger.info(&#34;ping:&#34; + str(num))
    output = num
    return &#39;pong &#39; + str(output)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self, key, value, is_private=False, is_queued=False, tableName=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Access to data layer to store a data item in the form of a (key, value) pair.
By default, the put operation is reflected on the data layer immediately.
If the put operation is queued (i.e., is_queued = True),
the data item is put into the transient data table.
If the key was previously deleted by the function instance,
it is removed from the list of items to be deleted.
When the function instance finishes,
the transient data items are committed to the data layer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>the key of the data item</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>string</code></dt>
<dd>the value of the data item</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be written to the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the put operation should be reflected on the data layer after the execution finish; default: False
(i.e., the put operation will be reflected on the data layer immediately)</dd>
<dt><strong><code>tableName</code></strong> :&ensp;<code>string</code></dt>
<dd>name of the table where to put the key. By default, it will be put in the default table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the key and/or value are not strings.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self, key, value, is_private=False, is_queued=False, tableName=None):
    &#39;&#39;&#39;
    Access to data layer to store a data item in the form of a (key, value) pair.
    By default, the put operation is reflected on the data layer immediately.
    If the put operation is queued (i.e., is_queued = True),
    the data item is put into the transient data table.
    If the key was previously deleted by the function instance,
    it is removed from the list of items to be deleted.
    When the function instance finishes,
    the transient data items are committed to the data layer.

    Args:
        key (string): the key of the data item
        value (string): the value of the data item
        is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
        is_queued (boolean): whether the put operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the put operation will be reflected on the data layer immediately)
        tableName (string): name of the table where to put the key. By default, it will be put in the default table.

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the key and/or value are not strings.
    &#39;&#39;&#39;
    if py3utils.is_string(key) and py3utils.is_string(value) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.put(key, value, is_private, is_queued, table=tableName)
    else:
        errmsg = &#34;MicroFunctionsAPI.put(key, value) accepts a string as &#39;key&#39; and &#39;value&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.putMapEntry"><code class="name flex">
<span>def <span class="ident">putMapEntry</span></span>(<span>self, mapname, key, value, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>the key of the data item</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>string</code></dt>
<dd>the value of the data item</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be written to the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the put operation should be reflected on the data layer after the execution finish; default: False
(i.e., the put operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when any of mapname, key and value is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def putMapEntry(self, mapname, key, value, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map
        key (string): the key of the data item
        value (string): the value of the data item
        is_private (boolean): whether the item should be written to the private data layer of the workflow; default: False
        is_queued (boolean): whether the put operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the put operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when any of mapname, key and value is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(mapname) and py3utils.is_string(key) and py3utils.is_string(value) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.putMapEntry(mapname, key, value, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.putMapEntry(mapname, key, value) accepts a string as &#39;mapname&#39;, &#39;key&#39; and &#39;value&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, key, is_private=False, is_queued=False, tableName=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Access to data layer to remove data item associated with a given key.
By default, the remove operation is reflected on the data layer immediately.
If the delete operation is queued (i.e., is_queued = True),
the key is removed from the transient data table.
It is also added to the list of items to be deleted from the global
data layer when the function instance finishes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>the key of the data item</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be deleted from the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the delete operation should be reflected on the data layer after the execution finish; default: False
(i.e., the delete operation will be reflected on the data layer immediately)</dd>
<dt><strong><code>tableName</code></strong> :&ensp;<code>string</code></dt>
<dd>name of the table where to remove the key from. By default, it will be deleted from the default table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the key is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, key, is_private=False, is_queued=False, tableName=None):
    &#39;&#39;&#39;
    Access to data layer to remove data item associated with a given key.
    By default, the remove operation is reflected on the data layer immediately.
    If the delete operation is queued (i.e., is_queued = True),
    the key is removed from the transient data table.
    It is also added to the list of items to be deleted from the global
    data layer when the function instance finishes.

    Args:
        key (string): the key of the data item
        is_private (boolean): whether the item should be deleted from the private data layer of the workflow; default: False
        is_queued (boolean): whether the delete operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the delete operation will be reflected on the data layer immediately)
        tableName (string): name of the table where to remove the key from. By default, it will be deleted from the default table.

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when the key is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(key) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.delete(key, is_private, is_queued, table=tableName)
    else:
        errmsg = &#34;MicroFunctionsAPI.delete(key) accepts a string as &#39;key&#39;&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.removeSetEntry"><code class="name flex">
<span>def <span class="ident">removeSetEntry</span></span>(<span>self, setname, item, is_private=False, is_queued=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>setname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the set</dd>
<dt><strong><code>item</code></strong> :&ensp;<code>string</code></dt>
<dd>the item to be removed from the set</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the item should be removed from the private data layer of the workflow; default: False</dd>
<dt><strong><code>is_queued</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the remove operation should be reflected on the data layer after the execution finish; default: False
(i.e., the remove operation will be reflected on the data layer immediately)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when any of setname and item is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeSetEntry(self, setname, item, is_private=False, is_queued=False):
    &#39;&#39;&#39;
    Args:
        setname (string): the name of the set
        item (string): the item to be removed from the set
        is_private (boolean): whether the item should be removed from the private data layer of the workflow; default: False
        is_queued (boolean): whether the remove operation should be reflected on the data layer after the execution finish; default: False
            (i.e., the remove operation will be reflected on the data layer immediately)

    Returns:
        None

    Raises:
        MicroFunctionsDataLayerException: when any of setname and item is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(setname) and py3utils.is_string(item) and isinstance(is_private, bool) and isinstance(is_queued, bool):
        self._data_layer_operator.removeSetEntry(setname, item, is_private, is_queued)
    else:
        errmsg = &#34;MicroFunctionsAPI.removeSetEntry(setname, item) accepts a string as &#39;setname&#39; and &#39;item&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) and is_queued (boolean) are also accepted; defaults are False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.retrieveMap"><code class="name flex">
<span>def <span class="ident">retrieveMap</span></span>(<span>self, mapname, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the map to be retrieved</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the map should be retrieved from the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Map</code> of <code>data</code> <code>items</code> <code>as</code> <code>a</code> <code>collection</code> of (<code>key</code>, <code>value</code>) <code>pairs</code> (<code>dict</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the mapname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieveMap(self, mapname, is_private=False):
    &#39;&#39;&#39;
    Args:
        mapname (string): the name of the map to be retrieved
        is_private (boolean): whether the map should be retrieved from the private data layer of the workflow; default: False

    Returns:
        Map of data items as a collection of (key, value) pairs (dict)

    Raises:
        MicroFunctionsDataLayerException: when the mapname is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(mapname) and isinstance(is_private, bool):
        return self._data_layer_operator.retrieveMap(mapname, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.retrieveMap(mapname) accepts a string as &#39;mapname&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.retrieveSet"><code class="name flex">
<span>def <span class="ident">retrieveSet</span></span>(<span>self, setname, is_private=False)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>setname</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the set to be retrieved</dd>
<dt><strong><code>is_private</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the set should be retrieved from the private data layer of the workflow; default: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Set</code> of <code>set</code> <code>items</code> (<code>set</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsDataLayerException</code></strong></dt>
<dd>when the setname is not a string.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieveSet(self, setname, is_private=False):
    &#39;&#39;&#39;
    Args:
        setname (string): the name of the set to be retrieved
        is_private (boolean): whether the set should be retrieved from the private data layer of the workflow; default: False

    Returns:
        Set of set items (set)

    Raises:
        MicroFunctionsDataLayerException: when the setname is not a string.

    &#39;&#39;&#39;
    if py3utils.is_string(setname) and isinstance(is_private, bool):
        return self._data_layer_operator.retrieveSet(setname, is_private)
    else:
        errmsg = &#34;MicroFunctionsAPI.retrieveSet(setname) accepts a string as &#39;setname&#39;.&#34;
        errmsg = errmsg + &#34;\nOptionally, is_private (boolean) is also accepted; default is False.&#34;
        raise MicroFunctionsDataLayerException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.send_to_all_running_functions_in_session"><code class="name flex">
<span>def <span class="ident">send_to_all_running_functions_in_session</span></span>(<span>self, message, send_now=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a message to all long-running session function instances in this session.</p>
<h2 id="args">Args</h2>
<dl>
<dt>message (*): the 'message' to be sent; can be any python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</dt>
<dt><strong><code>send_now</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the message should be sent immediately or at the end of current function's execution; default: False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_all_running_functions_in_session(self, message, send_now=False):
    &#39;&#39;&#39;
    Send a message to all long-running session function instances in this session.

    Args:
        message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
        send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

    Returns:
        None

    &#39;&#39;&#39;
    # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
    # we make the conversion according to the runtime
    message = self._publication_utils.convert_api_message_to_python_object(message)

    if not self._publication_utils.is_valid_value(message):
        errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
        raise MicroFunctionsSessionAPIException(errmsg)

    if self._is_session_workflow:
        self._session_utils.send_to_all_running_functions_in_session(message, send_now)
    else:
        self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.send_to_all_running_functions_in_session_with_function_name"><code class="name flex">
<span>def <span class="ident">send_to_all_running_functions_in_session_with_function_name</span></span>(<span>self, gname, message, send_now=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a message to all long-running session function instances identified with their function name in this session.
There can be multiple instances with the same function name, which will all receive the message.
The function name refers to the function name;
it is not to be confused with the 'alias' that may have been assigned to each long-running, session function instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gname</code></strong> :&ensp;<code>string</code></dt>
<dd>the function name (i.e., function name) of the running long-running session function instance(s).</dd>
<dt>message (*): the 'message' to be sent; can be any python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</dt>
<dt><strong><code>send_now</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the message should be sent immediately or at the end of current function's execution; default: False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_all_running_functions_in_session_with_function_name(self, gname, message, send_now=False):
    &#39;&#39;&#39;
    Send a message to all long-running session function instances identified with their function name in this session.
    There can be multiple instances with the same function name, which will all receive the message.
    The function name refers to the function name;
    it is not to be confused with the &#39;alias&#39; that may have been assigned to each long-running, session function instance.

    Args:
        gname (string): the function name (i.e., function name) of the running long-running session function instance(s).
        message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
        send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

    Returns:
        None

    &#39;&#39;&#39;
    # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
    # we make the conversion according to the runtime
    message = self._publication_utils.convert_api_message_to_python_object(message)

    if not self._publication_utils.is_valid_value(message):
        errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
        raise MicroFunctionsSessionAPIException(errmsg)

    if self._is_session_workflow:
        self._session_utils.send_to_all_running_functions_in_session_with_function_name(gname, message, send_now)
    else:
        self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.send_to_function_now"><code class="name flex">
<span>def <span class="ident">send_to_function_now</span></span>(<span>self, destination, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a new event message to another function immediately instead of waiting until the end of the current function execution.
The destination can be any function in the workflow description.
The value must be a python data type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>destination</code></strong> :&ensp;<code>string</code></dt>
<dd>the destination of the message</dd>
</dl>
<p>value (*): message to be sent; must be a python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsWorkflowException</code></strong></dt>
<dd>when either the destination is not a string or the value is not a python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_function_now(self, destination, value):
    &#39;&#39;&#39;
    Send a new event message to another function immediately instead of waiting until the end of the current function execution.
    The destination can be any function in the workflow description.
    The value must be a python data type.

    Args:
        destination (string): the destination of the message
        value (*): message to be sent; must be a python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

    Raises:
        MicroFunctionsWorkflowException: when either the destination is not a string or the value is not a python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).

    &#39;&#39;&#39;
    # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
    # we make the conversion according to the runtime
    value = self._publication_utils.convert_api_message_to_python_object(value)

    is_valid, is_privileged, errmsg = self._publication_utils.is_valid_trigger_message(destination, value, True)

    if is_valid:
        trigger = {}
        trigger[&#34;next&#34;] = destination
        trigger[&#34;value&#34;] = value
        trigger[&#34;is_privileged&#34;] = is_privileged
        self._publication_utils.send_to_function_now(self._instanceid, trigger)
    else:
        raise MicroFunctionsWorkflowException(errmsg)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.send_to_running_function_in_session"><code class="name flex">
<span>def <span class="ident">send_to_running_function_in_session</span></span>(<span>self, rgid, message, send_now=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a message to a long-running session function instance identified with its id in this session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rgid</code></strong> :&ensp;<code>string</code></dt>
<dd>the running long-running session function instance's id.</dd>
<dt>message (*): the 'message' to be sent; can be any python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</dt>
<dt><strong><code>send_now</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the message should be sent immediately or at the end of current function's execution; default: False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_running_function_in_session(self, rgid, message, send_now=False):
    &#39;&#39;&#39;
    Send a message to a long-running session function instance identified with its id in this session.

    Args:
        rgid (string): the running long-running session function instance&#39;s id.
        message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
        send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

    Returns:
        None

    &#39;&#39;&#39;
    # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
    # we make the conversion according to the runtime
    message = self._publication_utils.convert_api_message_to_python_object(message)

    if not self._publication_utils.is_valid_value(message):
        errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
        raise MicroFunctionsSessionAPIException(errmsg)

    if self._is_session_workflow:
        self._session_utils.send_to_running_function_in_session(rgid, message, send_now)
    else:
        self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.send_to_running_function_in_session_with_alias"><code class="name flex">
<span>def <span class="ident">send_to_running_function_in_session_with_alias</span></span>(<span>self, alias, message, send_now=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a message to a long-running session function instance identified with its alias in this session.
The alias would have to be assigned before calling this function.
The alias can belong to only a single long-running, session function instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alias</code></strong> :&ensp;<code>string</code></dt>
<dd>the alias of the running long-running session function instance that is the destination of the message.</dd>
<dt>message (*): the 'message' to be sent; can be any python data type (<type 'dict', 'list', 'str', 'int', 'float', or 'NoneType'>).</dt>
<dt><strong><code>send_now</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether the message should be sent immediately or at the end of current function's execution; default: False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_running_function_in_session_with_alias(self, alias, message, send_now=False):
    &#39;&#39;&#39;
    Send a message to a long-running session function instance identified with its alias in this session.
    The alias would have to be assigned before calling this function.
    The alias can belong to only a single long-running, session function instance.

    Args:
        alias (string): the alias of the running long-running session function instance that is the destination of the message.
        message (*): the &#39;message&#39; to be sent; can be any python data type (&lt;type &#39;dict&#39;, &#39;list&#39;, &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, or &#39;NoneType&#39;&gt;).
        send_now (boolean): whether the message should be sent immediately or at the end of current function&#39;s execution; default: False.

    Returns:
        None

    &#39;&#39;&#39;
    # _XXX_: Java objects need to be serialized and passed to python; however, API functions expect python objects
    # we make the conversion according to the runtime
    message = self._publication_utils.convert_api_message_to_python_object(message)

    if not self._publication_utils.is_valid_value(message):
        errmsg = &#34;Malformed message: &#39;message&#39; must a python data type (dict, list, str, int, float, or None).&#34;
        raise MicroFunctionsSessionAPIException(errmsg)

    if self._is_session_workflow:
        self._session_utils.send_to_running_function_in_session_with_alias(alias, message, send_now)
    else:
        self._logger.warning(&#34;Cannot send a session update message in a workflow with no session functions.&#34;)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.set_session_alias"><code class="name flex">
<span>def <span class="ident">set_session_alias</span></span>(<span>self, alias)</span>
</code></dt>
<dd>
<section class="desc"><p>Assign an alias to the current session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alias</code></strong> :&ensp;<code>string</code></dt>
<dd>the custom name to be assigned to the session.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsSessionAPIException</code></strong></dt>
<dd>when the alias is not a string, or is empty string.</dd>
</dl>
<h2 id="warns">Warns</h2>
<p>When the alias is already in use by another session.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_session_alias(self, alias):
    &#39;&#39;&#39;
    Assign an alias to the current session.

    Args:
        alias (string): the custom name to be assigned to the session.

    Returns:
        None

    Raises:
        MicroFunctionsSessionAPIException: when the alias is not a string, or is empty string.

    Warns:
        When the alias is already in use by another session.

    &#39;&#39;&#39;
    if not py3utils.is_string(alias) or alias == &#34;&#34;:
        raise MicroFunctionsSessionAPIException(&#34;Invalid session alias; must be a non-empty string.&#34;)
    elif alias == &#34;&#34;:
        raise MicroFunctionsSessionAPIException(&#34;Session alias cannot be empty.&#34;)

    if self._is_session_workflow:
        self._session_utils.set_session_alias(alias)
    else:
        self._logger.warning(&#34;Cannot set a session alias in a workflow with no session functions.&#34;)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.set_session_function_alias"><code class="name flex">
<span>def <span class="ident">set_session_function_alias</span></span>(<span>self, alias, session_function_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Assign an alias to a session function instance in this session.
If the session function id is not set, the alias will be assigned to the calling function instance.
If it is set, the alias will be assigned to the function instance with the given id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alias</code></strong> :&ensp;<code>string</code></dt>
<dd>the custom name to be assigned to the session function instance.</dd>
<dt><strong><code>session_function_id</code></strong> :&ensp;<code>string</code></dt>
<dd>the session function instance id for which this alias should be assigned; default: None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>MicroFunctionsSessionAPIException</code></strong></dt>
<dd>when the alias is not a string, or is empty string</dd>
</dl>
<h2 id="warns">Warns</h2>
<p>When calling function is not a session function.
When no session function instance exists with the given session function id.
When the alias is already in use by another existing session function instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_session_function_alias(self, alias, session_function_id=None):
    &#39;&#39;&#39;
    Assign an alias to a session function instance in this session.
    If the session function id is not set, the alias will be assigned to the calling function instance.
    If it is set, the alias will be assigned to the function instance with the given id.

    Args:
        alias (string): the custom name to be assigned to the session function instance.
        session_function_id (string): the session function instance id for which this alias should be assigned; default: None

    Returns:
        None

    Raises:
        MicroFunctionsSessionAPIException: when the alias is not a string, or is empty string

    Warns:
        When calling function is not a session function.
        When no session function instance exists with the given session function id.
        When the alias is already in use by another existing session function instance.

    &#39;&#39;&#39;
    if not py3utils.is_string(alias):
        raise MicroFunctionsSessionAPIException(&#34;Invalid session function alias; must be a non-empty string.&#34;)
    elif alias == &#34;&#34;:
        raise MicroFunctionsSessionAPIException(&#34;Session function alias cannot be empty.&#34;)

    # handle another session function&#39;s alias
    if session_function_id is not None:
        self._session_utils.set_session_function_alias(alias, session_function_id)
    elif self._is_session_function:
        self._session_utils.set_session_function_alias(alias)
    else:
        self._logger.warning(&#34;Cannot set a session function alias in a non-session function.&#34;)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.unset_session_alias"><code class="name flex">
<span>def <span class="ident">unset_session_alias</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove the existing alias of the current session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unset_session_alias(self):
    &#39;&#39;&#39;
    Remove the existing alias of the current session.

    Args:
        None

    Returns:
        None

    &#39;&#39;&#39;
    self._session_utils.unset_session_alias()</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.unset_session_function_alias"><code class="name flex">
<span>def <span class="ident">unset_session_function_alias</span></span>(<span>self, session_function_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove the current alias of the session function instance in this session.
If the session function id is not set, the current function instance's alias will be removed.
If it is set, the alias of the session function instance corresponding to the id will be removed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>session_function_id</code></strong> :&ensp;<code>string</code></dt>
<dd>the id of the session function instance whose alias should be removed; default: None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="warns">Warns</h2>
<p>When calling function is not a session function if session function id is None.
When no session function instance exists with the given session function id.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unset_session_function_alias(self, session_function_id=None):
    &#39;&#39;&#39;
    Remove the current alias of the session function instance in this session.
    If the session function id is not set, the current function instance&#39;s alias will be removed.
    If it is set, the alias of the session function instance corresponding to the id will be removed.

    Args:
        session_function_id (string): the id of the session function instance whose alias should be removed; default: None.

    Returns:
        None

    Warns:
        When calling function is not a session function if session function id is None.
        When no session function instance exists with the given session function id.

    &#39;&#39;&#39;
    # handle another session function&#39;s alias
    if session_function_id is not None:
        self._session_utils.unset_session_function_alias(session_function_id)
    elif self._is_session_function:
        self._session_utils.unset_session_function_alias()
    else:
        self._logger.warning(&#34;Cannot unset a session function alias in a non-session function.&#34;)</code></pre>
</details>
</dd>
<dt id="MicroFunctionsAPI.MicroFunctionsAPI.update_metadata"><code class="name flex">
<span>def <span class="ident">update_metadata</span></span>(<span>self, metadata_name, metadata_value, is_privileged_metadata=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_metadata(self, metadata_name, metadata_value, is_privileged_metadata=False):
    is_privileged = False
    if is_privileged_metadata and self._is_privileged:
        is_privileged = True

    self._publication_utils.update_metadata(metadata_name, metadata_value, is_privileged=is_privileged)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MicroFunctionsAPI.MicroFunctionsAPI" href="#MicroFunctionsAPI.MicroFunctionsAPI">MicroFunctionsAPI</a></code></h4>
<ul class="">
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.addSetEntry" href="#MicroFunctionsAPI.MicroFunctionsAPI.addSetEntry">addSetEntry</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.addStorageTriggerForWorkflow" href="#MicroFunctionsAPI.MicroFunctionsAPI.addStorageTriggerForWorkflow">addStorageTriggerForWorkflow</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.addTriggerableTable" href="#MicroFunctionsAPI.MicroFunctionsAPI.addTriggerableTable">addTriggerableTable</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.add_dynamic_next" href="#MicroFunctionsAPI.MicroFunctionsAPI.add_dynamic_next">add_dynamic_next</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.add_dynamic_workflow" href="#MicroFunctionsAPI.MicroFunctionsAPI.add_dynamic_workflow">add_dynamic_workflow</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.add_workflow_next" href="#MicroFunctionsAPI.MicroFunctionsAPI.add_workflow_next">add_workflow_next</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.clearMap" href="#MicroFunctionsAPI.MicroFunctionsAPI.clearMap">clearMap</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.clearSet" href="#MicroFunctionsAPI.MicroFunctionsAPI.clearSet">clearSet</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.containsMapKey" href="#MicroFunctionsAPI.MicroFunctionsAPI.containsMapKey">containsMapKey</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.containsSetItem" href="#MicroFunctionsAPI.MicroFunctionsAPI.containsSetItem">containsSetItem</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.createCounter" href="#MicroFunctionsAPI.MicroFunctionsAPI.createCounter">createCounter</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.createMap" href="#MicroFunctionsAPI.MicroFunctionsAPI.createMap">createMap</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.createSet" href="#MicroFunctionsAPI.MicroFunctionsAPI.createSet">createSet</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.decrementCounter" href="#MicroFunctionsAPI.MicroFunctionsAPI.decrementCounter">decrementCounter</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.delete" href="#MicroFunctionsAPI.MicroFunctionsAPI.delete">delete</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.deleteCounter" href="#MicroFunctionsAPI.MicroFunctionsAPI.deleteCounter">deleteCounter</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.deleteMap" href="#MicroFunctionsAPI.MicroFunctionsAPI.deleteMap">deleteMap</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.deleteMapEntry" href="#MicroFunctionsAPI.MicroFunctionsAPI.deleteMapEntry">deleteMapEntry</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.deleteSet" href="#MicroFunctionsAPI.MicroFunctionsAPI.deleteSet">deleteSet</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.deleteStorageTriggerForWorkflow" href="#MicroFunctionsAPI.MicroFunctionsAPI.deleteStorageTriggerForWorkflow">deleteStorageTriggerForWorkflow</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.deleteTriggerableTable" href="#MicroFunctionsAPI.MicroFunctionsAPI.deleteTriggerableTable">deleteTriggerableTable</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get" href="#MicroFunctionsAPI.MicroFunctionsAPI.get">get</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.getCounterNames" href="#MicroFunctionsAPI.MicroFunctionsAPI.getCounterNames">getCounterNames</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.getCounterValue" href="#MicroFunctionsAPI.MicroFunctionsAPI.getCounterValue">getCounterValue</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.getMapEntry" href="#MicroFunctionsAPI.MicroFunctionsAPI.getMapEntry">getMapEntry</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.getMapKeys" href="#MicroFunctionsAPI.MicroFunctionsAPI.getMapKeys">getMapKeys</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.getMapNames" href="#MicroFunctionsAPI.MicroFunctionsAPI.getMapNames">getMapNames</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.getSetNames" href="#MicroFunctionsAPI.MicroFunctionsAPI.getSetNames">getSetNames</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.getTriggerableTables" href="#MicroFunctionsAPI.MicroFunctionsAPI.getTriggerableTables">getTriggerableTables</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.getWorkflowDetails" href="#MicroFunctionsAPI.MicroFunctionsAPI.getWorkflowDetails">getWorkflowDetails</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_alias_summary" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_alias_summary">get_alias_summary</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_all_session_function_aliases" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_all_session_function_aliases">get_all_session_function_aliases</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_all_session_function_ids" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_all_session_function_ids">get_all_session_function_ids</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_data_to_be_deleted" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_data_to_be_deleted">get_data_to_be_deleted</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_dynamic_workflow" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_dynamic_workflow">get_dynamic_workflow</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_event_key" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_event_key">get_event_key</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_instance_id" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_instance_id">get_instance_id</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_privileged_data_layer_client" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_privileged_data_layer_client">get_privileged_data_layer_client</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_remaining_time_in_millis" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_remaining_time_in_millis">get_remaining_time_in_millis</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_session_alias" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_session_alias">get_session_alias</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_alias" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_alias">get_session_function_alias</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_id" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_id">get_session_function_id</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_id_with_alias" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_session_function_id_with_alias">get_session_function_id_with_alias</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_session_id" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_session_id">get_session_id</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_session_update_messages" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_session_update_messages">get_session_update_messages</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.get_transient_data_output" href="#MicroFunctionsAPI.MicroFunctionsAPI.get_transient_data_output">get_transient_data_output</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.incrementCounter" href="#MicroFunctionsAPI.MicroFunctionsAPI.incrementCounter">incrementCounter</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.invokeManagementAction" href="#MicroFunctionsAPI.MicroFunctionsAPI.invokeManagementAction">invokeManagementAction</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.is_still_running" href="#MicroFunctionsAPI.MicroFunctionsAPI.is_still_running">is_still_running</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.log" href="#MicroFunctionsAPI.MicroFunctionsAPI.log">log</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.ping" href="#MicroFunctionsAPI.MicroFunctionsAPI.ping">ping</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.put" href="#MicroFunctionsAPI.MicroFunctionsAPI.put">put</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.putMapEntry" href="#MicroFunctionsAPI.MicroFunctionsAPI.putMapEntry">putMapEntry</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.remove" href="#MicroFunctionsAPI.MicroFunctionsAPI.remove">remove</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.removeSetEntry" href="#MicroFunctionsAPI.MicroFunctionsAPI.removeSetEntry">removeSetEntry</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.retrieveMap" href="#MicroFunctionsAPI.MicroFunctionsAPI.retrieveMap">retrieveMap</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.retrieveSet" href="#MicroFunctionsAPI.MicroFunctionsAPI.retrieveSet">retrieveSet</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.send_to_all_running_functions_in_session" href="#MicroFunctionsAPI.MicroFunctionsAPI.send_to_all_running_functions_in_session">send_to_all_running_functions_in_session</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.send_to_all_running_functions_in_session_with_function_name" href="#MicroFunctionsAPI.MicroFunctionsAPI.send_to_all_running_functions_in_session_with_function_name">send_to_all_running_functions_in_session_with_function_name</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.send_to_function_now" href="#MicroFunctionsAPI.MicroFunctionsAPI.send_to_function_now">send_to_function_now</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.send_to_running_function_in_session" href="#MicroFunctionsAPI.MicroFunctionsAPI.send_to_running_function_in_session">send_to_running_function_in_session</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.send_to_running_function_in_session_with_alias" href="#MicroFunctionsAPI.MicroFunctionsAPI.send_to_running_function_in_session_with_alias">send_to_running_function_in_session_with_alias</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.set_session_alias" href="#MicroFunctionsAPI.MicroFunctionsAPI.set_session_alias">set_session_alias</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.set_session_function_alias" href="#MicroFunctionsAPI.MicroFunctionsAPI.set_session_function_alias">set_session_function_alias</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.unset_session_alias" href="#MicroFunctionsAPI.MicroFunctionsAPI.unset_session_alias">unset_session_alias</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.unset_session_function_alias" href="#MicroFunctionsAPI.MicroFunctionsAPI.unset_session_function_alias">unset_session_function_alias</a></code></li>
<li><code><a title="MicroFunctionsAPI.MicroFunctionsAPI.update_metadata" href="#MicroFunctionsAPI.MicroFunctionsAPI.update_metadata">update_metadata</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>